## WHILE 循环语句编译器综合报告

> 说明：本报告以本项目实际实现的 **复合语句 + while 语言子集** 为对象，从形式化定义、算法设计到实现与测试进行系统整理。为了突出思考过程，以下内容尽量用自然语言、数学形式与伪代码，而不直接堆砌具体程序代码。  

---

### 1. 复合语句的形式化定义

在本项目中，“复合语句”是构成程序主体的基本结构之一，它允许顺序地组合多条简单语句和循环语句。我们可以从 **语言层面** 与 **语义层面** 两方面对其进行形式化。

#### 1.1 语法层面的定义

我们考虑的程序由语句块 `B` 构成，核心产生式可抽象为：

- 语句块（复合语句）：  
  \[ B \rightarrow S\;";"\;B\ |\ S\;";"\ |\ A\;B\ |\ A \]
- 简单语句：  
  \[ S \rightarrow \text{赋值语句} \mid \text{变量声明} \mid \text{表达式语句} \mid \text{\texttt{break}} \mid \text{\texttt{continue}} \]
- 循环语句：  
  \[ A \rightarrow \texttt{while}\ "(" L ")"\ M\ "\{" B "\}" \]

其中：
- `B` 表示复合语句（语句序列），
- `S` 表示简单语句，
- `A` 表示 `while` 循环，
- `L` 表示逻辑表达式，`M` 是为回填服务的辅助非终结符。

从结构上看：
- 复合语句允许 **任意多条**（包括 1 条）简单语句/循环语句顺序出现；
- 通过在 `B` 中递归嵌套 `A`，实现了 **循环结构与语句序列的融合**；
- 语句末尾统一使用 `";"` 作为分隔符，使语法简单明快。

这种定义隐含了一个设计取舍：**不引入显式的“复合语句界定符”（如 C 语言的 `{ ... }`）来包围任意语句序列，而是将花括号限定在循环体之内**。这使得文法更简单，但也意味着“最外层程序”就是一个顶层语句块 `B`。

#### 1.2 语义层面的理解

从语义上，复合语句的含义是：

- 对于 `B → S ; B`：先执行语句 `S`，再执行语句块 `B`；
- 对于 `B → S ;`：只执行一条语句 `S`；
- 对于 `B → A B`：先执行循环语句 `A`，再执行语句块 `B`；
- 对于 `B → A`：只执行循环语句 `A`。

在代码生成时，这一语义通过 **顺序拼接三地址码序列** 实现：每条语句或循环在归约时生成对应的中间代码，复合语句的代码序列就是各子语句代码的顺序连接。

---

### 2. 语言形式化描述

本节从 **正规式与 DFA**、**上下文无关文法** 与 **属性文法 + 中间代码形式** 三个层次，形式化描述本项目处理的语言。

#### 2.1 正规式的描述和 DFA 的定义（词法层面）

在词法分析阶段，我们关心的是对 **单个 Token** 的识别，因此使用正规式与 DFA 描述以下类别：

- **标识符（Identifier）**  
  - 正规式：  
    \[ \text{ID} = ( \text{Letter} \mid "\_" ) (\text{Letter} \mid \text{Digit} \mid "\_")^* \]
  - 其中：`Letter = [A-Za-z]`，`Digit = [0-9]`。

- **数字常量（Number）**  
  - 支持整数与浮点数（不考虑指数形式），在实现中等价于：  
    - 整数：`[0-9]+`  
    - 小数：`[0-9]+\.[0-9]+` 或 `. [0-9]+`（实现时对 `.5` 的情况自动加前导 0）。  
  - 为了更好报错，程序在 DFA 中区分了“合法单一小数点”和“多小数点”两种路径。

- **关键字（Keywords）**  
  \[ \{\texttt{while},\ \texttt{break},\ \texttt{continue},\ \texttt{int},\ \texttt{float},\ \texttt{true},\ \texttt{false}\} \]
  - 从实现角度看，先按标识符 DFA 识别出 ID，再用保留字表进行关键字判定。

- **运算符和分隔符（Operators & Delimiters）**  
  - 单字符：`+ - * / ( ) { } ; ,`  
  - 关系/逻辑运算符：`> < >= <= == != && || !`  
  - 赋值运算符：`=`  
  - 自增自减：`++ --`

在实现中，这些正规式通过 **手写扫描器 + 条件分支** 隐式地实现为 DFA：

- 对于 ID：从起始状态遇到 `Letter/_` 转入 “ID 状态”，在该状态自环接收 `Letter/Digit/_`，遇到其他字符转入终止态并回退一个字符。
- 对于 Number：从起始状态遇到 `Digit` 转入 “整数状态”，遇到 `.` 可能转入“小数状态”；一旦在小数状态再次遇到 `.`，则转入“错误状态”，报告“多个小数点”的词法错误。
- 对于 `&&` / `||`：从起始状态遇到 `&` 或 `|` 时，检查下一个字符决定进入“合法双字符状态”或“错误状态”，并据此给出“缺少第二个 &/|”的友好报错。

**设计思考**：
- 并没有把全部 DFA 明确画出，而是用 if/while 组合在代码中“编码”了每个 DFA 分支路径；
- 在碰到模棱两可的模式（例如 `.` 开头的数字）时，设计了一个“先假设为浮点数并补 0，再在扫描过程中纠错”的策略，这兼顾了灵活性与错误诊断信息的丰富度。

#### 2.2 文法的描述（语法层面）

在语法层面，本项目使用一个适合 LR(1) 分析的 **上下文无关文法**，其核心结构可以概括为：

- **程序结构**  
  \[ S' \rightarrow B \]

- **语句块（复合语句）**  
  \[ B \rightarrow S\;";"\;B \mid S\;";" \mid A\;B \mid A \]

- **循环结构**  
  \[ A \rightarrow \texttt{while}\ "(" L ")" M "\{" B "\}" \]

- **逻辑表达式**  
  \[
  \begin{aligned}
  L &\rightarrow L\ \texttt{||}\ M1 \mid M1 \\
  M1 &\rightarrow M1\ \texttt{\&\&}\ N \mid N \\
  N &\rightarrow \texttt{!}\ N \mid C \mid "(" L ")" \mid G \\
  C &\rightarrow E\ ROP\ E \\
  ROP &\rightarrow \texttt{>} \mid \texttt{<} \mid \texttt{==} \mid \texttt{>=} \mid \texttt{<=} \mid \texttt{!=}
  \end{aligned}
  \]

- **算术表达式**  
  \[
  \begin{aligned}
  E &\rightarrow E\ \texttt{+}\ F \mid E\ \texttt{-}\ F \mid F \\
  F &\rightarrow F\ \texttt{*}\ G \mid F\ \texttt{/}\ G \mid G \\
  G &\rightarrow \texttt{-}\ G \mid i \mid n \mid "(" E ")" \mid i\texttt{++} \mid \texttt{++}i \mid i\texttt{--} \mid \texttt{--}i \mid \texttt{true} \mid \texttt{false}
  \end{aligned}
  \]

- **简单语句与声明**  
  \[
  \begin{aligned}
  S &\rightarrow i\ \texttt{=}\ E \mid G \mid \texttt{break} \mid \texttt{continue} \\
    &\mid \texttt{int}\ i \mid \texttt{float}\ i \mid \texttt{int}\ i\ \texttt{=}\ E \mid \texttt{float}\ i\ \texttt{=}\ E
  \end{aligned}
  \]

该文法具有以下特点：

- 通过 **左递归** 实现二元运算符的 **左结合性**，与一般表达式文法一致；
- 通过将逻辑表达式层次化（`L/M1/N/C`），自然体现逻辑运算与关系运算的优先级差异；
- 通过引入辅助非终结符 `M`，为 while 条件与循环体之间留出了执行“回填条件跳转”的语义动作位置，结构上仍然保持 LR(1) 分析友好。

#### 2.3 属性文法和中间代码形式的定义

从属性文法的角度，本项目的文法属于 **综合属性文法**（所有属性在自底向上归约时即可计算），核心思想是：

- 为大部分表达式相关非终结符（如 `E, F, G, L, M1, N, C, S` 等）定义一个综合属性：
  - 记为 `val`，在实现中对应 `SemItem.name`，表示“该子表达式/语句对应的中间结果名（变量名或临时变量名）”；
- 在每条产生式上附加语义规则，通过生成 **三地址码** 来体现语义。

举例说明属性与中间代码的对应关系（这里用伪代码表示语义规则）：

- 产生式 `E → E1 + F`
  - 语义规则：
    - 生成新临时变量 `t = newTemp()`；
    - 产生三地址码：`t := E1.val + F.val`；
    - 令 `E.val = t`。

- 产生式 `S → i = E`
  - 语义规则：
    - 产生三地址码：`i := E.val`；
    - 令 `S.val = i`（便于在更大上下文中统一处理）。

- 产生式 `C → E1 ROP E2`
  - 语义规则：
    - `t = newTemp()`；
    - 产生三地址码：`t := (E1.val ROP E2.val)`；
    - `C.val = t`。

- 产生式 `A → while ( L ) M { B }`
  - 语义规则的大致流程：
    1. 在进入 `while` 时记录当前指令地址作为循环测试起点（通过 `enterLoop()` 完成）；
    2. 表达式 `L` 归约时产出布尔结果 `L.val`（可能是临时变量或 `true/false`）；
    3. 在 `M → ε` 归约时根据 `L.val` 生成条件跳转（如 `jz L.val, PENDING_EXIT`），并记录其地址以便回填；
    4. `B` 归约时处理 `break/continue`，分别将 `goto PENDING_EXIT` 和 `goto PENDING_TEST` 的位置存入对应列表；
    5. 在整个 `A` 归约结束时，统一回填所有 `PENDING_EXIT` / `PENDING_TEST`，并生成跳回条件测试起点的无条件跳转（`goto testStart`）。

**中间代码形式**：

- 采用典型的 **三地址码（TAC）** 表示：
  - 一条指令形如 `(op, arg1, arg2, result)`，在实现中还带有 `addr` 作为指令序号：
    - 算术：`result := arg1 op arg2`
    - 赋值：`result := arg1`
    - 条件跳转：`if arg1 == 0 goto result`（对应 `jz`）
    - 无条件跳转：`goto result`
    - 声明：`decl type result`
- 同时保留了 **四元式** 形式 `(op, arg1, arg2, result)`，主要用于在语法分析步骤中展示每次归约产生的语义动作结果，增强可视化与可调试性。

---

### 3. 编译程序的算法设计

本节重点从 **整体思路** 而非代码细节，描述词法、语法与语义分析的算法设计。为避免技术堆砌，我们以流程图/伪代码 + 文字说明的方式呈现。

#### 3.1 词法分析方法的设计

**目标**：从源代码字符串中依次抽取 Token，记录每个 Token 的类型与位置，同时在发现非法模式时给出尽可能精准和友好的错误信息。

可以把词法分析看作一个 **驱动 DFA 的主循环**：

```pseudo
line ← 1, col ← 1
i ← 0
tokens ← []

WHILE i < input.length DO
    跳过空白（空格/制表符/换行），同步更新 line, col
    记录当前起始位置 startLine, startCol
    
    IF 是单行注释起始 "//" THEN
        跳到行尾
        CONTINUE
    ELSE IF 是多行注释起始 "/*" THEN
        在一个小循环中搜索 "*/"
        若未找到则报“注释未闭合”错误
        CONTINUE
    ENDIF

    根据当前字符分类：
        - 若是标识符/关键字起始 → 按 ID 的 DFA 扫描，结束后在关键字表中查找
        - 若是数字/小数点 → 按 Number 的 DFA 扫描，过程中检测“多小数点/尾点”
        - 若是运算符/分隔符起始 → 根据当前和下一个字符区分单/双字符运算符
        - 否则 → 报非法字符错误

    将识别出的 token（含 sym, token, typeLabel, startLine, startCol）加入 tokens
ENDWHILE

追加结束符 "#" 到 tokens
```

**设计侧重点**：

1. **定位精度**：每个 Token 从扫描开始就记录 `startLine/startCol`，错误信息基于此位置而非“扫描结束位置”，避免列号偏移。
2. **错误可读性**：对于数字和运算符相关错误，在错误信息中引入“第一个小数点位置”、“期望 '&&' 却出现单个 '&'”等语义性说明，帮助用户理解错误原因。
3. **对注释的健壮处理**：多行注释未闭合是初学者常见错误，因此专门记录注释起始行列，并在错误提示中说明注释跨越的行数和起点，方便快速定位。

#### 3.2 语法分析方法的设计

**总体策略**：采用 **自底向上的 LR(1) 分析**，其动机是：

- 文法中存在左递归与较复杂的优先级/结合性设计，用 LL(1) 等自顶向下方法较难直接处理；

- LR(1) 能自然处理较复杂的表达式与控制结构，并通过向前看符号解决大部分冲突问题。

**分析表构建阶段（离线）**：

1. 明确所有产生式（46 条），构建非终结符集 `Vn` 与终结符集 `Vt`；
2. 计算所有非终结符的 First 集；
3. 构造 LR(1) 项目集族：
   - 从增广项目 `[S' → ·B, #]` 出发，不断对项目集做 `closure` 和 `goto` 运算；
4. 对每个状态和符号，根据 `goto` 结果填充 `actionTable` 与 `gotoTable`；
5. 将结果导出为 `items.txt` 和 `table.csv`，便于人工验证和调试。

**分析执行阶段（在线）**：

语法分析主循环可以用经典 LR 伪代码概括：

```pseudo
初始化：
    stateStack ← [0]
    symbolStack ← ["#"]
    semStack ← []
    ptr ← 0  // 指向当前输入 token

LOOP
    s ← stateStack.top()
    a ← 将 tokens[ptr] 映射为文法终结符（如 "i"/"n"/"while"/"+" 等）

    IF actionTable[s][a] 不存在 THEN
        // 语法错误：
        - 根据当前状态对应的项目集推导“期望符号集合 expected”
        - 结合 symbolStack 与 braceLineStack（记录 '{' 的行号）
        - 使用 diagnoseSyntaxError(...) 诊断错误类型
        - 输出带位置/期望符号/诊断的错误信息
        终止分析
    ENDIF

    act ← actionTable[s][a]

    CASE act.type OF
        SHIFT:
            若 a 是 "while" 则调用 enterLoop() 记录循环起点
            若 a 是 "{" 或 "}" 则更新 braceLineStack
            将 act.target 压入 stateStack
            将 a 压入 symbolStack
            将 tokens[ptr].token 封装为 SemItem 压入 semStack
            ptr ← ptr + 1

        REDUCE:
            p ← 对应的产生式
            从三栈中各弹出 |p.right| 个元素，将语义项收集到 popped 向量中（并反转）
            调用 CodeGenerator.handleProduction(p.id, popped, semStack) 生成中间代码并得到 res
            将 p.left 压入 symbolStack
            根据 gotoTable[stateStack.top()][p.left] 压入新状态
            将 res 压入 semStack

        ACCEPT:
            分析成功，结束循环
    ENDCASE
ENDLOOP
```

**设计思考**：

- 将 **文法结构（productions）** 与 **分析表（action/goto）** 明确分离，便于调试和理论分析；
- 在错误处理上，不仅依赖“当前状态没有动作”这一信号，还利用项目集信息推导期望符号，从而构造出更有指导意义的错误提示；
- 使用 `braceLineStack` 单独跟踪代码块起点，专门解决“缺少右花括号”这一高频、易混淆错误。

#### 3.3 语义分析方法的设计（含伪代码与说明）

语义分析在本项目中与 **中间代码生成** 高度耦合，主要通过 `semStack + CodeGenerator` 实现。思路可以抽象为：

1. **语义值统一模型**：
   - 任何表达式/语句的归约结果都以一个 `SemItem` 表示，其核心字段 `name` 表示该子表达式产生的“值的名字”（可以是源语言变量名，也可以是临时变量名 `T1/T2/...`）。

2. **语义规则的触发时机**：
   - 仅在 **REDUCE** 阶段执行，即每当某个产生式被应用时调用一次 `handleProduction(prodId, popped, semStack)`。

3. **核心语义过程伪代码**：

```pseudo
function handleProduction(prodId, popped, semStack) -> SemItem
    res ← SemItem("")

    SWITCH prodId
        CASE 对应算术产生式 (E → E + F / E - F / F * G / F / G):
            t ← newTemp()
            生成三地址码： t := popped[0].name (op) popped[2].name
            res.name ← t

        CASE 对应赋值语句 (S → i = E):
            生成三地址码： popped[0].name := popped[2].name
            res.name ← popped[0].name

        CASE 对应关系/逻辑运算 (C, L, M1, N 等):
            t ← newTemp()
            生成三地址码： t := (左操作数) (运算符) (右操作数或一元操作数)
            res.name ← t

        CASE 对应变量/常量(G → i / G → n / G → true / G → false):
            res.name ← popped[0].name

        CASE 对应自增自减 (i++ / ++i / i-- / --i):
            按前缀/后缀含义调整：
                - 后缀：先保存原值，再修改变量本身，res 为原值
                - 前缀：先修改变量本身，res 为新值
            用 2~3 条 TAC 表达这一过程

        CASE 对应声明语句 (int i; / int i = E; 等):
            生成“decl type i”和可选的初始化赋值三地址码
            res.name ← 标识符名

        CASE while 循环中的 M → ε:
            从 semStack 中取出条件 L 的结果名 cond
            若 cond 为 true 则无需条件跳转（无限循环）
            否则生成 jz cond, PENDING_EXIT，并记录其地址到 break 列表

        CASE A → while ( L ) M { B }:
            调用 exitLoop():
                - 生成跳回测试起点的 goto
                - 回填本层所有 break 到循环出口
                - 回填本层所有 continue 到循环测试起点

        CASE 对应 break / continue:
            生成 goto PENDING_EXIT / PENDING_TEST
            将当前指令地址加入对应列表

        DEFAULT:
            // 对于一些“纯传递”产生式，直接把子节点的语义值传上去即可
            若 popped 非空则 res.name ← popped[0].name

    RETURN res
```

**设计重点**：

- 将“循环的控制流复杂性”全部压缩在少数几条产生式（`A` 与 `M`，`break`/`continue`）上处理，而其他表达式类产生式只关注值计算本身；
- 通过「进入循环时记测试起点 + 在 M 中集中生成条件跳转 + 在退出循环时统一回填」的方式，避免在多个地方维护相同的控制流信息，降低错误概率；
- 使用统一的 `SemItem` 抽象，保证表达式与语句的语义传递逻辑在结构上保持一致。 

---

### 4. 编译程序的实现和测试

#### 4.1 程序实现：三种分析方法的结合

整体实现可以看作一个“分层流水线 + 适度交叉”的结构：

1. **Lexer：输入端**  
   - 提供 `performLexicalAnalysis(input)`，输出 `vector<Word>`，并记录/打印词法错误。

2. **Parser：结构骨架**  
   - 在构造时完成文法/First 集/项目集/分析表构建，并导出 `items.txt` / `table.csv`；
   - 对外提供只读访问接口，用于语法分析主循环查询 `actionTable` / `gotoTable` 等。

3. **CodeGenerator：语义引擎**  
   - 提供 `handleProduction` 等接口，在每次归约时被调用，生成三地址码与四元式；
   - 内部持有 TAC 序列和循环控制栈结构。

4. **WhileCompiler：总控模块**  
   - 串起词法分析、语法分析和代码生成：

```pseudo
function run(input):
    // 阶段 1：词法分析
    tokens ← lexer.performLexicalAnalysis(input)
    打印词法分析表
    若 lexer.hasErrors() 为真则输出错误汇总并返回

    // 阶段 2：语法分析 + 语义动作
    初始化 stateStack, symbolStack, semStack, braceLineStack
    从 Parser 获取 actionTable, gotoTable, productions, states 等

    WHILE true:
        根据 stateStack.top() 和当前 token（经映射为 a）查找动作 act
        若未找到动作则触发语法错误处理并返回

        IF act 为 SHIFT:
            根据 a 可能调用 enterLoop / 更新 braceLineStack
            三栈同步压入状态/符号/语义项
            ptr 前进

        ELSE IF act 为 REDUCE:
            根据产生式长度从三栈弹出相应元素
            调用 codegen.handleProduction(...) 执行语义动作
            将产生式左部及 GOTO 后的状态压回栈

        ELSE IF act 为 ACCEPT:
            分析结束，跳出循环
    ENDWHILE

    // 阶段 3：输出中间代码
    codegen.printTAC()
```

**结合方式的设计特点**：

- 词法分析与语法/语义分析“前后分离”，确保语法阶段看到的是一个完整的 Token 序列，这使得语法错误定位可以完全依赖 Token 级位置信息；
- 语义分析与语法分析紧密耦合：每一次 REDUCE 都是一次“局部语义合成”的机会，三者通过 `semStack` 与 `handleProduction` 形成了自然的桥接；
- 模块之间通过清晰的接口连接，各自内部则可自由演进，例如后续可以替换成 LALR 分析表、引入更复杂的优化等，而不影响整体框架。

#### 4.2 程序的测试：用例设计与结果分析

为了验证编译器在 **功能覆盖、优先级与结合性、错误处理与定位** 等方面的正确性，设计了多类测试用例。

##### 4.2.1 表达式优先级与结合性测试

典型测试文件（如 `test_priority.txt`）包含：

```c
int x = 1 + 2 * 3 ;
int y = ( 1 + 2 ) * 3 ;
int z = 10 - 5 - 2 ;
```

**预期行为**：

- `x`：先算 `2 * 3 = 6`，再 `1 + 6 = 7` → 乘除高于加减；
- `y`：括号改变优先级，先 `1 + 2 = 3`，再 `3 * 3 = 9`；
- `z`：减法左结合，`(10 - 5) - 2 = 3`。

**TAC 结果分析**（概念层面）：

- 对 `x`：期望生成形如：
  - `T1 := 2 * 3`
  - `x := 1 + T1`
- 对 `y`：
  - `T1 := 1 + 2`
  - `y := T1 * 3`
- 对 `z`：
  - `T1 := 10 - 5`
  - `z := T1 - 2`

这些结果表明：文法层次设计、LR(1) 分析表以及 `handleProduction` 的语义规则在整体上正确反映了运算优先级与结合性的预期。

##### 4.2.2 语法结构与循环控制测试

选取嵌套 while + break/continue 的典型程序，例如：

```c
while ( true ) {
    float b_flag = 1.5 ;
    if_val = a_var ;
    while ( b < 1 ) {
        break ;
    }
    continue ;
    b = a_var ++ ;
}
```

**关注点**：

- 外层 while 体内部的声明、赋值、自增、break、continue 是否都能正确生成三地址码；
- 内外层循环的 `break`/`continue` 是否分别回填到正确的测试起点与循环出口；
- TAC 中是否能清晰体现嵌套循环的控制流结构（多层 `jz` + `goto` 与合适的标签）。

测试结果表明：通过 `loopAddrStack` 与 `breakLists` / `continueLists` 的设计，所有与当前层循环相关的跳转都被限制在各自的栈帧内，避免了交叉干扰，嵌套结构在中间代码中也清晰可见。

##### 4.2.3 错误处理测试

**词法错误用例**：

- 非法字符：`int x = 1 + 2 * 3 @ ;`
- 数字格式错误：`1.2.3`、`1.`
- 单个 `&` / `|`：`a & b;`、`a | b;`
- 注释未闭合：`/* comment ...`

**观察点**：

- 报错行列是否与源码中实际位置一致（特别要注意制表符与多行注释的影响）；
- 错误消息是否包含有用上下文，例如“第一个小数点位置”、“注释起始位置”等。

**语法错误用例**：

- 少分号：`int a = 1  int b = 2;`
- 少右括号：`while ( a < 10 { ... }`
- 少右花括号：缺少与某个 `{` 对应的 `}`，直到文件结束。

**观察点**：

- 报错行列基本指向“遇到意外符号”的位置，并在诊断信息中说明“真正问题可能发生在前一条语句末尾”；
- EOF 情况下是否优先诊断为“缺少右花括号”，并能够指出未匹配 `{` 的起点行号。

总体来看，错误处理系统能够较准确地反映错误类型与近似位置，在学习和调试过程中具有较好的指导意义。

---

### 5. 总结与反思

本项目尝试在一个相对小巧的 WHILE 语言子集上，完整走了一遍“正规式/DFA → 上下文无关文法 → LR(1) 分析表 → 属性文法与中间代码 → 错误处理”的编译器设计路径。其核心经验与反思如下：

1. **形式化与工程实现的折中**：  
   - 词法层面虽然可以为每一类 Token 画出标准 DFA，但在工程中通常采用“分类分支 + 状态变量”的方式隐式编码 DFA，这样更容易与错误信息与位置跟踪逻辑融合。

2. **文法设计对后续阶段的影响**：  
   - 为 LR(1) 分析调整文法（例如使用左递归、拆分逻辑表达式层次）会直接影响 First 集、项目集与分析表的形状，也影响语义动作挂载的位置；
   - 强行在“语义友好”的文法上做 LR(1) 解析往往会碰到冲突，适度改变文法、引入辅助非终结符（如 `M`）是一个实用的手段。

3. **属性文法的视角有助于统一思维**：  
   - 用“每个非终结符都携带一个或几个属性”的方式来思考语义，比直接在代码中穿插各种 if/else 生成中间代码更清晰，可帮助我们检查是否存在“语义遗漏”或“语义依赖方向错误”。

4. **错误处理不应只是“发现错误”，而应尽量“解释错误”**：  
   - 在本项目中，无论是词法还是语法错误，设计时都有意识地加入“期望的符号”、“诊断信息”和“位置提示”等内容，尽量模拟真实编译器（如 GCC/Clang）给出的用户体验；
   - 从教学和学习角度，这比“简单打印错误行列”更有价值。

5. **中间代码是连接“语法世界”和“机器世界”的桥梁**：  
   - 通过三地址码表示，可以清晰地观察表达式求值顺序、临时变量生命周期和控制流结构；
   - 若有需要，本项目后续可以在 TAC 的基础上实现数据流分析与简单优化，再进一步生成目标代码或解释执行。

总体而言，本项目并不是要构造一个“工业级编译器”，而是希望在可控的复杂度下，完整实践一条从形式化定义到工程实现再到测试与反思的编译器设计路径。这一过程本身比“功能多少”更重要，也更能体现编译原理这门课强调的 **抽象思维与系统设计能力**。 


