# 编译器功能实现详解

## 目录
1. [项目概述](#项目概述)
2. [模块架构](#模块架构)
3. [词法分析器 (Lexer)](#词法分析器-lexer)
4. [语法分析器 (Parser)](#语法分析器-parser)
5. [代码生成器 (CodeGenerator)](#代码生成器-codegenerator)
6. [编译器主类 (WhileCompiler)](#编译器主类-whilecompiler)
7. [数据结构详解](#数据结构详解)
8. [算法实现细节](#算法实现细节)

---

## 项目概述

本项目实现了一个基于 **LR(1)** 分析方法的编译器，支持 while 循环、变量声明、表达式计算等功能的 while 语言编译器。编译器将源代码转换为三地址码（TAC）形式的中间代码。

### 支持的语法特性
- **循环结构**：while 循环，支持 break 和 continue
- **变量声明**：int 和 float 类型变量，支持初始化
- **表达式**：算术表达式（+、-、*、/）、逻辑表达式（&&、||、!）
- **关系运算**：比较运算符（>、<、==、>=、<=、!=）
- **自增自减**：前置和后置的 ++、-- 运算符
- **布尔值**：true 和 false

---

## 模块架构

```
┌─────────────┐
│   main.cpp  │  ← 程序入口，文件读取
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  Compiler   │  ← 编译器主类，协调各模块
└──────┬──────┘
       │
       ├──────────┬──────────┬──────────┐
       ▼          ▼          ▼          ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│  Lexer  │ │ Parser  │ │ CodeGen │ │  Types  │
└─────────┘ └─────────┘ └─────────┘ └─────────┘
词法分析   语法分析    代码生成    数据结构
```

### 编译流程
```
源代码 → 词法分析 → Token序列 → 语法分析 → 语法树 → 代码生成 → 三地址码
```

---

## 词法分析器 (Lexer)

### 功能概述
词法分析器负责将源代码字符串分解为一系列词法单元（Token），识别关键字、标识符、数字、运算符等。

### 核心方法

#### 1. `performLexicalAnalysis(const string& input)`
**功能**：执行词法分析的主函数

**实现细节**：
- 使用状态机方式逐个字符扫描输入
- 维护行号和列号信息，用于错误报告
- 识别不同类型的词法单元：
  - **标识符和关键字**：以字母或下划线开头，后跟字母、数字或下划线
  - **数字**：支持整数和小数（如 1.5）
  - **运算符**：单字符（+、-、*、/）和双字符（++、--、&&、||、==、!=、>=、<=）
  - **分隔符**：括号、大括号、分号等

**关键字识别**：
```cpp
while, break, continue, int, float, true, false
```

**符号码编码**：
- 0: 标识符
- 1: 数字
- 2: 运算符/关系运算符
- 3: 符号（括号、分号等）
- 4: 逻辑运算符
- 5: 自增/自减运算符
- 36-42: 关键字（while, break, continue, int, float, true, false）

#### 2. `isIdStart(char c)` 和 `isIdPart(char c)`
**功能**：判断字符是否为标识符的起始字符或组成部分

**实现**：
- `isIdStart`: 字母或下划线
- `isIdPart`: 字母、数字或下划线

#### 3. `reportLexicalError(int line, int col, char c, const string& reason)`
**功能**：报告词法错误

**错误类型**：
- 非法字符
- 数字格式错误（多个小数点、以小数点结尾）
- 不完整的运算符（单独的 & 或 |）

---

## 语法分析器 (Parser)

### 功能概述
语法分析器使用 **LR(1)** 方法构建分析表，并执行语法分析。LR(1) 是自底向上的分析方法，能够处理更复杂的语法。

### 核心数据结构

#### 产生式集合
定义了 46 个产生式，覆盖所有语法规则：
- 程序结构：`S' → B`, `B → S; B | S; | A B | A`
- 循环结构：`A → while ( L ) M { B }`
- 逻辑表达式：`L → L || M1 | M1`, `M1 → M1 && N | N`
- 表达式：`E → E + F | E - F | F`
- 变量声明：`S → int i | float i | int i = E | float i = E`

#### LR(1) 分析表
- **Action 表**：状态 × 终结符 → 动作（移进/归约/接受/错误）
- **Goto 表**：状态 × 非终结符 → 新状态

### 核心方法

#### 1. `computeFirst()`
**功能**：计算所有非终结符的 First 集合

**算法**：
- 迭代算法，直到没有新的元素加入
- 对于产生式 `A → α`：
  - 如果 `α` 为空，则 `epsilon ∈ First(A)`
  - 如果 `α[0]` 是终结符，则 `α[0] ∈ First(A)`
  - 如果 `α[0]` 是非终结符，则 `First(α[0]) - {epsilon} ⊆ First(A)`

**用途**：计算向前看符号集合，解决归约-归约冲突

#### 2. `getFirst(const vector<string>& symbols)`
**功能**：计算符号串的 First 集合

**实现**：
- 依次检查每个符号
- 遇到终结符则返回该终结符
- 遇到非终结符则加入其 First 集合（不含 epsilon）
- 如果某个非终结符的 First 包含 epsilon，继续检查下一个符号

#### 3. `getClosure(vector<LR1Item> items)`
**功能**：计算 LR(1) 项目集的闭包

**算法**：
对于项目 `[A → α·Bβ, a]`：
1. 如果 `B` 是非终结符，对于所有产生式 `B → γ`：
   - 计算 `First(βa)`，得到新的向前看符号集合
   - 添加项目 `[B → ·γ, First(βa)]`
2. 重复直到没有新项目加入

**关键点**：
- 向前看符号的计算：`First(βa)` 而不是 `First(β)`
- 这是 LR(1) 与 LR(0) 的主要区别

#### 4. `buildLR1Table()`
**功能**：构建 LR(1) 分析表

**算法步骤**：
1. **初始化**：创建初始状态 `I0 = closure({[S' → ·B, #]})`
2. **状态构建**：
   - 对于每个状态 `Ii` 和每个符号 `X`：
     - 计算 `goto(Ii, X))`
     - 如果新状态不存在，创建新状态
     - 如果 `X` 是终结符，在 Action 表中添加移进动作
     - 如果 `X` 是非终结符，在 Goto 表中添加转移
3. **归约动作**：
   - 对于项目 `[A → α·, a]`，在 Action[i][a] 中添加归约动作
   - 对于 `[S' → B·, #]`，添加接受动作

**状态比较**：
- 使用完整的 LR1Item 比较（包括向前看符号）
- 这是 **LR(1)** 而非 **LALR(1)** 的特征

#### 5. `saveItemsToFile()` 和 `saveTableToCSV()`
**功能**：将分析表保存到文件，便于调试和验证

---

## 代码生成器 (CodeGenerator)

### 功能概述
代码生成器在语法分析过程中执行语义动作，生成三地址码（TAC）形式的中间代码。

### 核心数据结构

#### 循环控制栈
```cpp
stack<int> loopAddrStack;           // 循环测试地址栈
stack<vector<int>> breakLists;      // break 语句地址列表栈
stack<vector<int>> continueLists;   // continue 语句地址列表栈
```

**用途**：
- 支持嵌套循环
- 处理 break 和 continue 的跳转目标
- 实现循环的回填机制

### 核心方法

#### 1. `emit(op, a1, a2, res)`
**功能**：生成一条三地址码指令

**实现**：
- 创建 TAC 结构并添加到 `tacCode` 向量
- 自动分配指令地址（按顺序递增）

#### 2. `emitQuad(op, a1, a2, res)`
**功能**：生成四元式（用于语法分析过程显示）

**区别**：
- `emit`: 生成最终的三地址码
- `emitQuad`: 生成用于显示的中间表示

#### 3. `backpatch(addr, target)`
**功能**：回填跳转地址

**用途**：
- 在生成跳转指令时，目标地址可能未知
- 使用占位符（如 "PENDING_EXIT"）
- 后续通过回填设置正确的目标地址

#### 4. `handleProduction(prodId, popped, semStack)`
**功能**：处理产生式归约时的语义动作

**主要语义动作**：

**表达式计算**：
```cpp
case 15: // E → E + F
    res.name = newTemp();
    emit("+", popped[0].name, popped[2].name, res.name);
    break;
```

**变量赋值**：
```cpp
case 14: // S → i = E
    emit(":=", popped[2].name, "", popped[0].name);
    res.name = popped[0].name;
    break;
```

**变量声明**：
```cpp
case 39: // S → int i
    emit("decl", "int", "", popped[1].name);
    res.name = popped[1].name;
    break;
```

**循环控制**：
```cpp
case 1: // A → while ( L ) M { B }
    exitLoop();  // 处理循环结束，回填 break 和 continue
    break;

case 38: // M → epsilon
    // 生成循环条件跳转
    emit("jz", condition, "", "PENDING_EXIT");
    breakLists.top().push_back(jzIdx);
    break;
```

**break 和 continue**：
```cpp
case 36: // S → break
    handleBreak();  // 生成跳转到循环出口的指令
    break;

case 37: // S → continue
    handleContinue();  // 生成跳转到循环测试的指令
    break;
```

#### 5. `enterLoop()` 和 `exitLoop()`
**功能**：管理循环的进入和退出

**enterLoop()**：
- 记录循环测试地址
- 初始化 break 和 continue 列表

**exitLoop()**：
- 生成跳转到循环测试的指令
- 回填所有 break 语句的地址（跳转到循环出口）
- 回填所有 continue 语句的地址（跳转到循环测试）

---

## 编译器主类 (WhileCompiler)

### 功能概述
编译器主类整合词法分析、语法分析和代码生成三个模块，协调整个编译过程。

### 核心方法

#### `run(const string& input)`
**功能**：执行完整的编译过程

**执行流程**：

1. **词法分析阶段**：
   ```cpp
   vector<Word> tokens = lexer.performLexicalAnalysis(input);
   ```
   - 输出词法分析结果表格
   - 检查词法错误

2. **语法分析阶段**：
   - 初始化分析栈（状态栈、符号栈、语义栈）
   - LR(1) 分析循环：
     ```
     while (true) {
         当前状态 = 状态栈.top()
         当前符号 = tokens[ptr]
         查找 Action[当前状态][当前符号]
         
         if (SHIFT) {
             移进符号，转移到新状态
         }
         else if (REDUCE) {
             使用产生式归约
             执行语义动作（代码生成）
         }
         else if (ACCEPT) {
             分析成功
         }
         else {
             语法错误
         }
     }
     ```

3. **代码生成阶段**：
   - 在归约时调用 `codegen.handleProduction()`
   - 生成三地址码指令
   - 处理循环控制（break/continue 回填）

4. **输出阶段**：
   - 打印语法分析过程
   - 打印生成的三地址码

### 错误处理

**词法错误**：
- 位置信息（行号、列号）
- 错误原因描述

**语法错误**：
- 位置信息
- 期望的符号列表
- 帮助用户理解错误

---

## 数据结构详解

### Word（词法单元）
```cpp
struct Word {
    int sym;        // 符号码：用于语法分析
    string token;   // 词法值：原始字符串
    string typeLabel; // 类型标签：用于显示
    int line, col;  // 位置信息：用于错误报告
};
```

### LR1Item（LR(1) 项目）
```cpp
struct LR1Item {
    int prodId;         // 产生式ID
    int dotPos;         // 点位置（分析进度）
    set<string> lookahead; // 向前看符号集合
};
```

**示例**：
- `[E → E + ·F, {+, -, ;}]` 表示：已识别到 `E +`，期望 `F`，向前看符号为 `+`、`-` 或 `;`

### TAC（三地址码）
```cpp
struct TAC {
    string op, arg1, arg2, result;
    int addr;  // 指令地址
};
```

**示例**：
- `L0 | decl float b_flag`
- `L1 | b_flag := 1.5`
- `L2 | T1 := b < 1`
- `L3 | if T1 == 0 goto L7`

---

## 算法实现细节

### LR(1) 分析算法

#### 状态构建算法
```
1. I0 = closure({[S' → ·B, #]})
2. states = [I0]
3. for each state I in states:
     for each symbol X:
         next = goto(I, X)
         if next not in states:
             states.append(next)
         if X is terminal:
             Action[I][X] = SHIFT(next)
         else:
             Goto[I][X] = next
     for each item [A → α·, a] in I:
         Action[I][a] = REDUCE(A → α)
```

#### 分析过程算法
```
1. 初始化：stateStack = [0], symbolStack = [#], ptr = 0
2. while (true):
     s = stateStack.top()
     a = tokens[ptr]
     action = Action[s][a]
     
     if action == SHIFT:
         stateStack.push(action.target)
         symbolStack.push(a)
         ptr++
     else if action == REDUCE:
         pop |β| 个元素
         A = production[action.target].left
         stateStack.push(Goto[stateStack.top()][A])
         symbolStack.push(A)
         执行语义动作
     else if action == ACCEPT:
         break
     else:
         报告错误
```

### 代码生成算法

#### 循环处理算法
```
进入循环时：
    loopAddrStack.push(当前地址)
    breakLists.push([])
    continueLists.push([])

处理循环条件（M → epsilon）：
    emit("jz", condition, "", "PENDING_EXIT")
    breakLists.top().push_back(指令地址)

处理 break：
    emit("goto", "", "", "PENDING_EXIT")
    breakLists.top().push_back(指令地址)

处理 continue：
    emit("goto", "", "", "PENDING_TEST")
    continueLists.top().push_back(指令地址)

退出循环时：
    testAddr = loopAddrStack.top()
    emit("goto", "", "", testAddr)
    exitAddr = 当前地址
    
    for each addr in breakLists.top():
        backpatch(addr, exitAddr)
    for each addr in continueLists.top():
        backpatch(addr, testAddr)
```

#### 表达式计算算法
```
对于表达式 E → E + F：
    1. 递归处理 E，得到结果 temp1
    2. 递归处理 F，得到结果 temp2
    3. 生成：temp3 = temp1 + temp2
    4. 返回 temp3
```

---

## 总结

本编译器实现了完整的编译流程：

1. **词法分析**：将源代码转换为 Token 序列
2. **语法分析**：使用 LR(1) 方法验证语法正确性
3. **代码生成**：在语法分析过程中生成三地址码
4. **错误处理**：提供详细的错误信息和位置

**技术特点**：
- 使用 LR(1) 分析方法，分析能力强
- 支持嵌套循环和跳转语句
- 完整的错误报告机制
- 模块化设计，易于维护和扩展

**输出文件**：
- `items.txt`: LR(1) 项目集合
- `table.csv`: LR(1) 分析表
- 控制台输出：词法分析结果、语法分析过程、三地址码


