# 算法流程设计文档

本文档使用伪代码和流程图描述编译器的核心算法流程，包括词法分析、语法分析、语义分析以及特色功能的处理过程。

---

## 一、词法分析算法

### 1.1 词法分析主流程

词法分析器采用**有限状态自动机（DFA）**的思想，通过逐个扫描字符来识别Token。

#### 伪代码

```
算法: performLexicalAnalysis(input)
输入: 源代码字符串 input
输出: Token序列 tokens

BEGIN
    tokens = []
    i = 0, len = input.length()
    line = 1, col = 1
    
    WHILE i < len DO
        startLine = line
        startCol = col
        
        // 跳过空白字符
        IF input[i] == '\n' THEN
            line++
            col = 1
            i++
            CONTINUE
        END IF
        
        IF isspace(input[i]) THEN
            处理制表符和空格，更新col
            i++
            CONTINUE
        END IF
        
        // 处理注释
        IF input[i] == '/' AND input[i+1] == '/' THEN
            跳过单行注释到行尾
            CONTINUE
        END IF
        
        IF input[i] == '/' AND input[i+1] == '*' THEN
            处理多行注释，检查是否闭合
            IF 注释未闭合 THEN
                报告错误
            END IF
            CONTINUE
        END IF
        
        // 识别标识符和关键字
        IF isIdStart(input[i]) THEN
            buf = ""
            WHILE i < len AND isIdPart(input[i]) DO
                buf += input[i]
                i++
                col++
            END WHILE
            
            IF buf是关键字 THEN
                tokens.append(关键字Token)
            ELSE
                tokens.append(标识符Token)
            END IF
        END IF
        
        // 识别数字
        ELSE IF isdigit(input[i]) OR (input[i] == '.' AND isdigit(input[i+1])) THEN
            buf = ""
            dot = 0
            WHILE i < len AND (isdigit(input[i]) OR input[i] == '.') DO
                IF input[i] == '.' THEN
                    IF dot > 0 THEN
                        报告错误：多个小数点
                        BREAK
                    END IF
                    dot++
                END IF
                buf += input[i]
                i++
                col++
            END WHILE
            
            IF 数字合法 THEN
                tokens.append(数字Token)
            END IF
        END IF
        
        // 识别运算符
        ELSE IF input[i] == '&' THEN
            IF input[i+1] == '&' THEN
                tokens.append(逻辑与Token "&&")
                i += 2
            ELSE
                报告错误：缺少第二个&
            END IF
        END IF
        
        ELSE IF input[i] == '|' THEN
            IF input[i+1] == '|' THEN
                tokens.append(逻辑或Token "||")
                i += 2
            ELSE
                报告错误：缺少第二个|
            END IF
        END IF
        
        ELSE IF input[i] == '+' THEN
            IF input[i+1] == '+' THEN
                tokens.append(自增Token "++")
                i += 2
            ELSE
                tokens.append(加法Token "+")
                i++
            END IF
        END IF
        
        ELSE IF input[i] == '-' THEN
            IF input[i+1] == '-' THEN
                tokens.append(自减Token "--")
                i += 2
            ELSE
                tokens.append(减法Token "-")
                i++
            END IF
        END IF
        
        // 识别关系运算符和其他符号
        ELSE IF input[i] == '=' THEN
            IF input[i+1] == '=' THEN
                tokens.append(等于Token "==")
                i += 2
            ELSE
                tokens.append(赋值Token "=")
                i++
            END IF
        END IF
        
        // 识别分隔符
        ELSE IF input[i] IN {'(', ')', '{', '}', ';', ','} THEN
            tokens.append(分隔符Token)
            i++
            col++
        END IF
        
        // 非法字符处理
        ELSE THEN
            报告词法错误：非法字符
            i++
            col++
        END IF
    END WHILE
    
    tokens.append(结束符Token "#")
    RETURN tokens
END
```

#### 流程图

```
开始词法分析
    │
    ├─→ 初始化：tokens=[], i=0, line=1, col=1
    │
    ├─→ [i < len?]
    │   │
    │   ├─ 否 → 添加结束符"#" → 返回tokens
    │   │
    │   └─ 是 → 记录startLine, startCol
    │       │
    │       ├─→ [空白字符?] → 更新行号列号 → 继续
    │       │
    │       ├─→ [注释?] → 跳过注释 → 继续
    │       │
    │       ├─→ [字母/下划线?] → 识别标识符/关键字
    │       │                      ├─→ 关键字 → 添加关键字Token
    │       │                      └─→ 标识符 → 添加标识符Token
    │       │
    │       ├─→ [数字/小数点?] → 识别数字
    │       │                      ├─→ 合法 → 添加数字Token
    │       │                      └─→ 错误 → 报告错误
    │       │
    │       ├─→ [&?] → 检查"&&" → 添加逻辑与Token
    │       │
    │       ├─→ [|?] → 检查"||" → 添加逻辑或Token
    │       │
    │       ├─→ [+?] → 检查"++" → 添加自增或加法Token
    │       │
    │       ├─→ [-?] → 检查"--" → 添加自减或减法Token
    │       │
    │       ├─→ [=?] → 检查"==" → 添加等于或赋值Token
    │       │
    │       ├─→ [分隔符?] → 添加分隔符Token
    │       │
    │       └─→ [其他] → 报告非法字符错误
    │
    └─→ 结束
```

---

## 二、语法分析算法（LR(1)）

### 2.1 LR(1)分析主流程

LR(1)分析器采用**移进-归约**策略，使用分析表控制分析过程。

#### 伪代码

```
算法: LR1Parse(tokens, actionTable, gotoTable, productions)
输入: Token序列 tokens
      动作表 actionTable
      转移表 gotoTable
      产生式集合 productions
输出: 分析成功/失败

BEGIN
    stateStack = [0]          // 状态栈，初始状态0
    symbolStack = ["#"]       // 符号栈，栈底标记
    semStack = []             // 语义栈，存储语义信息
    ptr = 0                   // 输入指针
    
    WHILE TRUE DO
        s = stateStack.top()  // 当前状态
        a = tokens[ptr]       // 当前输入符号
        
        // 查找动作表
        IF actionTable[s][a] 不存在 THEN
            报告语法错误
            RETURN 失败
        END IF
        
        act = actionTable[s][a]
        
        // 接受动作
        IF act.type == ACCEPT THEN
            RETURN 成功
        END IF
        
        // 移进动作
        IF act.type == SHIFT THEN
            IF a == "while" THEN
                enterLoop()   // 进入循环处理
            END IF
            
            输出: "移进 S" + act.target
            stateStack.push(act.target)
            symbolStack.push(a)
            semStack.push_back({a.token})  // 保存Token原始值
            ptr++                           // 移动输入指针
        END IF
        
        // 归约动作
        IF act.type == REDUCE THEN
            p = productions[act.target]  // 获取产生式
            
            // 从栈中弹出产生式右部的符号
            popped = []
            FOR k = 0 TO p.right.size()-1 DO
                stateStack.pop()
                symbolStack.pop()
                popped.push_back(semStack.back())
                semStack.pop_back()
            END FOR
            reverse(popped)  // 反转顺序（栈是后进先出）
            
            // 执行语义动作，生成代码
            res = handleProduction(act.target, popped, semStack)
            
            // 压入产生式左部
            symbolStack.push(p.left)
            newState = gotoTable[stateStack.top()][p.left]
            stateStack.push(newState)
            semStack.push_back(res)
            
            输出: "归约 r" + act.target
        END IF
    END WHILE
END
```

#### 流程图

```
开始语法分析
    │
    ├─→ 初始化栈：stateStack=[0], symbolStack=["#"], semStack=[]
    │
    ├─→ [获取当前状态s和输入符号a]
    │
    ├─→ [查找actionTable[s][a]]
    │   │
    │   ├─→ 不存在 → 报告语法错误 → 结束
    │   │
    │   └─→ 存在 → act = actionTable[s][a]
    │       │
    │       ├─→ [act.type == ACCEPT?]
    │       │   └─→ 是 → 分析成功 → 结束
    │       │
    │       ├─→ [act.type == SHIFT?]
    │       │   └─→ 是 → 执行移进
    │       │              ├─→ 如果a=="while" → enterLoop()
    │       │              ├─→ stateStack.push(act.target)
    │       │              ├─→ symbolStack.push(a)
    │       │              ├─→ semStack.push_back({a.token})
    │       │              └─→ ptr++ → 继续循环
    │       │
    │       └─→ [act.type == REDUCE?]
    │           └─→ 是 → 执行归约
    │                      ├─→ 从栈中弹出产生式右部的符号
    │                      ├─→ handleProduction()生成代码
    │                      ├─→ symbolStack.push(产生式左部)
    │                      ├─→ 查找gotoTable获取新状态
    │                      └─→ stateStack.push(新状态) → 继续循环
    │
    └─→ 结束
```

### 2.2 语法分析表构建流程

#### LR(1)项目集闭包计算

```
算法: getClosure(items)
输入: 初始项目集合 items
输出: 闭包集合 closure

BEGIN
    changed = TRUE
    WHILE changed DO
        changed = FALSE
        FOR EACH item IN items DO
            IF item.dotPos >= productions[item.prodId].right.size() THEN
                CONTINUE  // 圆点在产生式末尾，跳过
            END IF
            
            B = productions[item.prodId].right[item.dotPos]  // 圆点后的符号
            
            IF B 是非终结符 THEN
                beta = 产生式右部圆点后的符号串
                nextLookahead = getFirst(beta + item.lookahead)
                
                // 添加B的所有产生式项目
                FOR EACH production p WHERE p.left == B DO
                    newItem = {p.id, 0, nextLookahead}
                    
                    IF newItem 不在items中 THEN
                        items.append(newItem)
                        changed = TRUE
                    ELSE
                        合并展望符集合
                        IF 展望符增加 THEN
                            changed = TRUE
                        END IF
                    END IF
                END FOR
            END IF
        END FOR
    END WHILE
    
    RETURN items
END
```

---

## 三、语义分析与代码生成

### 3.1 代码生成主流程

语义分析在语法分析的归约阶段执行，通过语义栈传递信息，生成中间代码。

#### 伪代码

```
算法: handleProduction(prodId, popped, semStack)
输入: 产生式编号 prodId
      弹出栈的语义信息 popped
      当前语义栈 semStack
输出: 归约后的语义项 res

BEGIN
    res = {""}
    
    SWITCH prodId DO
        // 算术运算：E → E + F
        CASE 15:  // E → E + F
            res.name = newTemp()
            emit("+", popped[0].name, popped[2].name, res.name)
            emitQuad("+", popped[0].name, popped[2].name, res.name)
            BREAK
        
        // 赋值语句：S → i = E
        CASE 14:
            emit(":=", popped[2].name, "", popped[0].name)
            emitQuad("=", popped[2].name, "_", popped[0].name)
            res.name = popped[0].name
            BREAK
        
        // 关系运算：C → E ROP E
        CASE 9:
            res.name = newTemp()
            emit(popped[1].name, popped[0].name, popped[2].name, res.name)
            emitQuad(popped[1].name, popped[0].name, popped[2].name, res.name)
            BREAK
        
        // 变量声明：S → int i
        CASE 39:
            emit("decl", "int", "", popped[1].name)
            emitQuad("decl", "int", "_", popped[1].name)
            res.name = popped[1].name
            BREAK
        
        // 其他产生式...
    END SWITCH
    
    RETURN res
END
```

---

## 四、特色功能算法流程

### 4.1 while循环处理流程

while循环的处理涉及循环进入、条件判断、循环体执行和循环退出四个阶段。

#### 伪代码

```
算法: While循环处理流程

// 阶段1: 遇到while关键字（移进时）
IF a == "while" THEN
    enterLoop()
    // 记录循环开始地址
    // 初始化break和continue列表
END IF

// 阶段2: 生成条件判断代码（M → ε 归约时）
IF prodId == 38 THEN  // M → ε
    condition = semStack[semStack.size()-2].name  // 条件表达式结果
    
    IF condition == "true" THEN
        // 无限循环，不需要条件判断
    ELSE
        jzAddr = emit("jz", condition, "", "PENDING_EXIT")
        emitQuad("jz", condition, "_", "PENDING_EXIT")
        breakLists.top().append(jzAddr)  // 保存待回填地址
    END IF
END IF

// 阶段3: 循环体代码生成（正常归约）
// 循环体中的语句正常生成代码
// 遇到break/continue时记录地址

// 阶段4: 循环结束处理（A → while(L)M{B} 归约时）
IF prodId == 1 THEN  // A → while(L)M{B}
    exitLoop()
END IF

算法: enterLoop()
BEGIN
    testStart = tacCode.size()  // 记录循环开始地址
    loopAddrStack.push(testStart)
    breakLists.push([])        // 初始化break列表
    continueLists.push([])     // 初始化continue列表
END

算法: exitLoop()
BEGIN
    testStart = loopAddrStack.top()
    loopAddrStack.pop()
    
    // 生成跳转回循环开始的指令
    emit("goto", "", "", "L" + testStart)
    emitQuad("j", "_", "_", testStart)
    
    exitAddr = tacCode.size()  // 循环结束地址
    
    // 回填break语句的地址
    brks = breakLists.top()
    breakLists.pop()
    FOR EACH addr IN brks DO
        backpatch(addr, "L" + exitAddr)
    END FOR
    
    // 回填continue语句的地址
    conts = continueLists.top()
    continueLists.pop()
    FOR EACH addr IN conts DO
        backpatch(addr, "L" + testStart)
    END FOR
END
```

#### 流程图

```
while循环处理流程
    │
    ├─→ [遇到"while"关键字]
    │   └─→ enterLoop()
    │       ├─→ testStart = 当前代码地址
    │       ├─→ loopAddrStack.push(testStart)
    │       ├─→ breakLists.push([])
    │       └─→ continueLists.push([])
    │
    ├─→ [生成条件表达式代码]
    │   └─→ 条件表达式归约 → 生成比较代码
    │
    ├─→ [M → ε 归约]
    │   └─→ 生成条件跳转指令
    │       ├─→ IF condition == "true" THEN
    │       │       └─→ 跳过条件判断
    │       │   ELSE
    │       │       ├─→ emit("jz", condition, "", "PENDING_EXIT")
    │       │       └─→ breakLists.top().append(jzAddr)
    │       └─→
    │
    ├─→ [循环体代码生成]
    │   ├─→ 正常语句 → 生成代码
    │   ├─→ break语句 → handleBreak()
    │   └─→ continue语句 → handleContinue()
    │
    └─→ [A → while(L)M{B} 归约]
        └─→ exitLoop()
            ├─→ 生成跳转回循环开始: goto L{testStart}
            ├─→ exitAddr = 当前代码地址
            ├─→ 回填所有break地址 → exitAddr
            └─→ 回填所有continue地址 → testStart
```

### 4.2 自增自减表达式处理流程

自增自减操作分为前缀和后缀两种情况，语义不同。

#### 伪代码

```
算法: 后缀自增 i++
CASE 31:  // G → i ++
BEGIN
    targetId = popped[0].name  // 变量名
    oldValue = newTemp()        // 保存原值的临时变量
    
    // 步骤1: 保存原值
    emit(":=", targetId, "", oldValue)
    emitQuad("=", targetId, "_", oldValue)
    
    // 步骤2: 计算新值并赋值
    t = newTemp()
    emit("+", targetId, "1", t)
    emit(":=", t, "", targetId)
    emitQuad("+", targetId, "1", t)
    emitQuad("=", t, "_", targetId)
    
    // 步骤3: 返回原值
    res.name = oldValue
END

算法: 前缀自增 ++i
CASE 32:  // G → ++ i
BEGIN
    targetId = popped[1].name  // 变量名
    
    // 步骤1: 计算新值并赋值
    t = newTemp()
    emit("+", targetId, "1", t)
    emit(":=", t, "", targetId)
    emitQuad("+", targetId, "1", t)
    emitQuad("=", t, "_", targetId)
    
    // 步骤2: 返回新值（自增后的值）
    res.name = targetId
END

算法: 后缀自减 i--
CASE 33:  // G → i --
BEGIN
    targetId = popped[0].name
    oldValue = newTemp()
    
    emit(":=", targetId, "", oldValue)
    emitQuad("=", targetId, "_", oldValue)
    
    t = newTemp()
    emit("-", targetId, "1", t)
    emit(":=", t, "", targetId)
    emitQuad("-", targetId, "1", t)
    emitQuad("=", t, "_", targetId)
    
    res.name = oldValue
END

算法: 前缀自减 --i
CASE 34:  // G → -- i
BEGIN
    targetId = popped[1].name
    
    t = newTemp()
    emit("-", targetId, "1", t)
    emit(":=", t, "", targetId)
    emitQuad("-", targetId, "1", t)
    emitQuad("=", t, "_", targetId)
    
    res.name = targetId
END
```

#### 流程图（后缀自增为例）

```
后缀自增 i++ 处理
    │
    ├─→ targetId = 变量名
    ├─→ oldValue = newTemp()  // 创建临时变量保存原值
    │
    ├─→ [保存原值]
    │   └─→ emit(":=", targetId, "", oldValue)
    │       └─→ 生成: oldValue := i
    │
    ├─→ [计算新值]
    │   └─→ t = newTemp()
    │       └─→ emit("+", targetId, "1", t)
    │           └─→ 生成: t := i + 1
    │
    ├─→ [自增操作]
    │   └─→ emit(":=", t, "", targetId)
    │       └─→ 生成: i := t
    │
    └─→ [返回原值]
        └─→ res.name = oldValue
            └─→ 表达式值为原值，但变量已自增
```

### 4.3 break和continue处理流程

break和continue语句需要记录跳转地址，在循环结束时统一回填。

#### 伪代码

```
算法: handleBreak()
BEGIN
    IF breakLists不为空 THEN
        addr = tacCode.size()  // 当前指令地址
        emit("goto", "", "", "PENDING_EXIT")
        emitQuad("j", "_", "_", "PENDING_EXIT")
        breakLists.top().append(addr)  // 保存待回填地址
    END IF
END

算法: handleContinue()
BEGIN
    IF continueLists不为空 THEN
        addr = tacCode.size()  // 当前指令地址
        emit("goto", "", "", "PENDING_TEST")
        emitQuad("j", "_", "_", "PENDING_TEST")
        continueLists.top().append(addr)  // 保存待回填地址
    END IF
END

// 在exitLoop()中回填
FOR EACH addr IN breakLists.top() DO
    backpatch(addr, "L" + exitAddr)  // 回填到循环结束
END FOR

FOR EACH addr IN continueLists.top() DO
    backpatch(addr, "L" + testStart)  // 回填到循环开始
END FOR
```

#### 流程图

```
break/continue处理流程
    │
    ├─→ [遇到break语句]
    │   └─→ handleBreak()
    │       ├─→ addr = 当前代码地址
    │       ├─→ emit("goto", "", "", "PENDING_EXIT")
    │       └─→ breakLists.top().append(addr)
    │
    ├─→ [遇到continue语句]
    │   └─→ handleContinue()
    │       ├─→ addr = 当前代码地址
    │       ├─→ emit("goto", "", "", "PENDING_TEST")
    │       └─→ continueLists.top().append(addr)
    │
    └─→ [循环结束exitLoop()时回填]
        ├─→ FOR EACH break地址 DO
        │       backpatch(addr, 循环结束地址)
        │   END FOR
        │
        └─→ FOR EACH continue地址 DO
                backpatch(addr, 循环开始地址)
            END FOR
```

### 4.4 逻辑运算短路求值处理流程

逻辑运算（&&和||）支持短路求值，但本项目采用完整的代码生成策略。

#### 伪代码

```
算法: 逻辑与运算 L → L || M1
CASE 2:
BEGIN
    res.name = newTemp()
    // 生成完整的逻辑或运算代码
    emit("||", popped[0].name, popped[2].name, res.name)
    emitQuad("||", popped[0].name, popped[2].name, res.name)
    // 注：虽然生成了完整的逻辑运算代码，但语义上支持短路求值
END

算法: 逻辑与运算 M1 → M1 && N
CASE 4:
BEGIN
    res.name = newTemp()
    // 生成完整的逻辑与运算代码
    emit("&&", popped[0].name, popped[2].name, res.name)
    emitQuad("&&", popped[0].name, popped[2].name, res.name)
END

算法: 逻辑非运算 N → ! N
CASE 6:
BEGIN
    res.name = newTemp()
    emit("!", popped[1].name, "", res.name)
    emitQuad("!", popped[1].name, "_", res.name)
END
```

#### 说明

本项目的逻辑运算代码生成采用**完整求值**策略，即生成完整的逻辑运算指令。虽然生成的中间代码中包含`&&`和`||`操作符，但在实际的代码生成中：

1. **逻辑与（&&）**：如果第一个操作数为假，结果必为假
2. **逻辑或（||）**：如果第一个操作数为真，结果必为真

这些优化可以在后续的代码优化阶段实现，当前阶段生成标准的逻辑运算指令即可。

### 4.5 复合语句处理流程

复合语句由多个语句顺序组成，代码生成采用顺序拼接策略。

#### 伪代码

```
算法: 复合语句处理

// 产生式：B → S ; B
CASE 10:  // B → S ; B
BEGIN
    // 无需特殊语义动作
    // 语句S的代码已生成
    // 语句块B的代码会在后续归约时生成
    // 复合语句的代码 = S的代码 + B的代码（顺序拼接）
    res.name = ""  // 复合语句无返回值
END

// 产生式：B → S ;
CASE 11:  // B → S ;
BEGIN
    // 单个语句，无需特殊处理
    res.name = ""
END

// 产生式：B → A B  (while循环后跟语句块)
CASE 12:
BEGIN
    // while循环A的代码 + 语句块B的代码
    res.name = ""
END

// 产生式：B → A  (单个while循环)
CASE 13:
BEGIN
    // 单个while循环的代码
    res.name = ""
END
```

#### 流程图

```
复合语句处理流程
    │
    ├─→ [B → S ; B 归约]
    │   └─→ 顺序拼接代码
    │       ├─→ S的代码（已生成）
    │       └─→ B的代码（后续生成）
    │
    ├─→ [B → S ; 归约]
    │   └─→ 单个语句的代码
    │
    ├─→ [B → A B 归约]
    │   └─→ 顺序拼接代码
    │       ├─→ while循环A的代码（已生成）
    │       └─→ 语句块B的代码（后续生成）
    │
    └─→ [B → A 归约]
        └─→ while循环A的代码
```

### 4.6 嵌套结构处理流程

本项目支持嵌套的while循环、嵌套的复合语句等结构，通过栈机制保证正确性。

#### 伪代码

```
算法: 嵌套循环处理示例

// 外层循环进入
enterLoop()  // 外层循环信息入栈
    loopAddrStack: [外层testStart]
    breakLists: [外层break列表]
    continueLists: [外层continue列表]

// 内层循环进入
enterLoop()  // 内层循环信息入栈
    loopAddrStack: [外层testStart, 内层testStart]
    breakLists: [外层break列表, 内层break列表]
    continueLists: [外层continue列表, 内层continue列表]

// 内层循环中的break
handleBreak()
    breakLists.top().append(内层break地址)  // 添加到内层列表

// 内层循环中的continue
handleContinue()
    continueLists.top().append(内层continue地址)  // 添加到内层列表

// 内层循环退出
exitLoop()
    // 回填内层的break和continue
    // 弹出内层循环信息
    loopAddrStack.pop()
    breakLists.pop()
    continueLists.pop()

// 外层循环退出
exitLoop()
    // 回填外层的break和continue
    // 弹出外层循环信息
    loopAddrStack.pop()
    breakLists.pop()
    continueLists.pop()
```

#### 嵌套结构栈状态图

```
嵌套循环的栈状态变化：

初始状态:
    loopAddrStack: []
    breakLists: []
    continueLists: []

外层循环进入:
    loopAddrStack: [L0]
    breakLists: [外[]]
    continueLists: [外[]]

内层循环进入:
    loopAddrStack: [L0, L5]
    breakLists: [外[], 内[]]
    continueLists: [外[], 内[]]

内层break/continue:
    loopAddrStack: [L0, L5]
    breakLists: [外[], 内[addr1]]
    continueLists: [外[], 内[addr2]]

内层循环退出:
    loopAddrStack: [L0]
    breakLists: [外[]]
    continueLists: [外[]]
    (内层地址已回填)

外层break/continue:
    loopAddrStack: [L0]
    breakLists: [外[addr3]]
    continueLists: [外[addr4]]

外层循环退出:
    loopAddrStack: []
    breakLists: []
    continueLists: []
    (外层地址已回填)
```

---

## 五、地址回填机制

### 5.1 回填算法

```
算法: backpatch(addr, target)
输入: 待回填的指令地址 addr
      目标地址 target
输出: 无

BEGIN
    IF addr >= 0 AND addr < tacCode.size() THEN
        tacCode[addr].result = target  // 修改指令的result字段
    END IF
END
```

### 5.2 回填时机

1. **循环条件跳转**：在`M → ε`归约时生成，使用`PENDING_EXIT`占位符
2. **break语句**：在`S → break`归约时生成，使用`PENDING_EXIT`占位符
3. **continue语句**：在`S → continue`归约时生成，使用`PENDING_TEST`占位符
4. **统一回填**：在`A → while(L)M{B}`归约时（即`exitLoop()`），统一回填所有待定地址

---

## 六、总结

本项目的算法设计特点：

1. **词法分析**：采用DFA思想，通过状态转换识别Token，支持关键字、标识符、数字、运算符、注释等
2. **语法分析**：采用LR(1)分析方法，使用移进-归约策略，支持完整的语法检查
3. **语义分析**：在归约时执行语义动作，通过语义栈传递信息，生成三地址码和四元式
4. **循环处理**：使用栈机制支持嵌套循环，通过地址回填机制处理break和continue
5. **表达式处理**：支持算术、关系、逻辑运算，以及自增自减操作，正确处理运算符优先级和结合性
6. **复合语句**：采用顺序拼接策略，简单高效

所有算法都经过精心设计，确保代码生成的正确性和效率。



