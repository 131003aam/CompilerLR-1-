# 功能支持说明

本文档说明编译器对以下功能的支持情况：

## ✅ 1. 括号支持

### 支持的括号类型

1. **表达式括号**：`G → ( E )`
   - 用于改变运算优先级
   - 示例：`( 1 + 2 ) * 3`

2. **逻辑表达式括号**：`N → ( L )`
   - 用于逻辑表达式的分组
   - 示例：`( a > 0 ) && ( b < 10 )`

3. **循环条件括号**：`A → while ( L ) M { B }`
   - while 循环的条件必须用括号包围

### 实现位置
- **产生式定义**：`parser.cpp` 第 24、8、1 行
- **语法规则**：
  ```cpp
  {24, "G", {"(", "E", ")"}},  // 表达式括号
  {8, "N", {"(", "L", ")"}},   // 逻辑表达式括号
  ```

### 测试示例
```cpp
int x = ( 1 + 2 ) * 3 ;  // ✅ 支持
while ( ( a > 0 ) && ( b < 10 ) ) { ... }  // ✅ 支持
```

---

## ✅ 2. 运算优先级

### 优先级层次（从高到低）

1. **最高优先级**：括号 `( )`
2. **单目运算符**：负号 `-`、逻辑非 `!`
3. **乘除运算**：`*`、`/`
4. **加减运算**：`+`、`-`
5. **关系运算符**：`>`, `<`, `==`, `>=`, `<=`, `!=`
6. **逻辑与**：`&&`
7. **逻辑或**：`||`

### 语法结构实现

```
E → E + F | E - F | F        (加减运算，优先级较低)
F → F * G | F / G | G        (乘除运算，优先级较高)
G → -G | i | n | (E) | ...   (因子，最高优先级)
```

**说明**：
- 通过语法层次结构实现优先级
- `E` 包含 `F`，`F` 包含 `G`
- 归约顺序保证了正确的优先级

### 实现位置
- **产生式定义**：`parser.cpp` 第 15-24 行
- **优先级规则**：
  ```cpp
  {15, "E", {"E", "+", "F"}},  // 加减：低优先级
  {16, "E", {"E", "-", "F"}},
  {18, "F", {"F", "*", "G"}},  // 乘除：高优先级
  {19, "F", {"F", "/", "G"}},
  {24, "G", {"(", "E", ")"}},  // 括号：最高优先级
  ```

### 测试示例
```cpp
int x = 1 + 2 * 3 ;      // 结果：7 (2*3先计算)
int y = ( 1 + 2 ) * 3 ;  // 结果：9 (括号改变优先级)
int z = 10 - 5 - 2 ;     // 结果：3 (左结合)
```

---

## ✅ 3. 运算结合性

### 左结合性

所有二元运算符都是**左结合**的，通过左递归产生式实现：

```cpp
E → E + F    // 左递归，实现左结合
F → F * G    // 左递归，实现左结合
L → L || M1  // 左递归，实现左结合
M1 → M1 && N // 左递归，实现左结合
```

### 结合性示例

**左结合（当前实现）**：
```cpp
10 - 5 - 2   // 解释为 (10 - 5) - 2 = 3
2 * 3 * 4    // 解释为 (2 * 3) * 4 = 24
a || b || c  // 解释为 (a || b) || c
```

### 实现位置
- **产生式定义**：`parser.cpp` 第 15-16, 18-19, 2, 4 行
- **左递归语法**：
  ```cpp
  {15, "E", {"E", "+", "F"}},   // 左递归
  {18, "F", {"F", "*", "G"}},   // 左递归
  {2, "L", {"L", "||", "M1"}},  // 左递归
  {4, "M1", {"M1", "&&", "N"}}, // 左递归
  ```

### 单目运算符结合性

**右结合**（通过右递归实现）：
```cpp
G → -G       // 右递归，实现右结合
N → !N       // 右递归，实现右结合
```

示例：
```cpp
--x          // 解释为 -(-x)
!!a          // 解释为 !(!a)
```

---

## ✅ 4. 词法错误报告

### 错误信息包含

1. **错误类型**：`[词法错误]`
2. **位置信息**：行号和列号（精确到字符）
3. **错误原因**：详细的错误描述
4. **遇到字符**：显示实际遇到的字符（特殊字符会转义）

### 实现位置
- **错误报告函数**：`lexer.cpp` 第 15-28 行
- **错误类型**：
  ```cpp
  void reportLexicalError(int line, int col, char c, const string& reason)
  ```

### 错误类型示例

1. **非法字符**：
   ```
   [词法错误] 第1行, 第10列: 非法字符 (遇到字符: '@')
   ```

2. **数字格式错误**：
   ```
   [词法错误] 第2行, 第15列: 数字中不能有多个小数点 (遇到字符: '.')
   [词法错误] 第3行, 第20列: 数字不能以小数点结尾 (遇到字符: '.')
   ```

3. **不完整的运算符**：
   ```
   [词法错误] 第1行, 第5列: 非法字符 '&'，期望 '&&' (遇到字符: '&')
   [词法错误] 第2行, 第8列: 非法字符 '|'，期望 '||' (遇到字符: '|')
   ```

### 特殊字符处理
- `\n` → 显示为 `\\n`
- `\t` → 显示为 `\\t`
- `\r` → 显示为 `\\r`

---

## ✅ 5. 语法错误报告

### 错误信息包含

1. **错误类型**：`[语法错误]`
2. **位置信息**：行号和列号（指向出错的 Token）
3. **遇到符号**：显示实际遇到的符号
4. **期望符号列表**：列出所有可能期望的符号

### 实现位置
- **错误处理**：`compiler.cpp` 第 127-162 行
- **期望符号收集**：
  ```cpp
  // 从当前状态的所有项目中提取期望的符号
  set<string> expected;
  // 检查移进项
  for (auto& it : states[s]) {
      if (it.dotPos < productions[it.prodId].right.size()) {
          string nextSym = productions[it.prodId].right[it.dotPos];
          if (Vt.count(nextSym)) expected.insert(nextSym);
      }
  }
  // 检查归约项（向前看符号）
  for (auto& it : states[s]) {
      if (it.dotPos == productions[it.prodId].right.size()) {
          for (auto& la : it.lookahead) {
              expected.insert(la);
          }
      }
  }
  ```

### 错误示例

```
[语法错误] 第5行, 第8列: 遇到意外的符号 '('
期望的符号: '++', '--', ';', '='
```

**说明**：
- 精确指出了错误位置（第5行第8列）
- 显示了实际遇到的符号 `'('`
- 列出了所有期望的符号，帮助用户理解错误原因

### 错误定位精度

- **词法错误**：定位到具体字符（行号 + 列号）
- **语法错误**：定位到 Token（Token 的起始位置）

---

## 功能验证测试

### 测试文件：`test_priority.txt`

```cpp
int x = 1 + 2 * 3 ;        // 测试优先级：* 优先于 +
int y = ( 1 + 2 ) * 3 ;    // 测试括号：改变优先级
int z = 10 - 5 - 2 ;      // 测试结合性：左结合
```

### 预期结果

1. **优先级测试**：
   - `1 + 2 * 3` → 先计算 `2 * 3 = 6`，再计算 `1 + 6 = 7`
   - 生成代码：`T1 := 2 * 3`, `x := 1 + T1`

2. **括号测试**：
   - `( 1 + 2 ) * 3` → 先计算 `1 + 2 = 3`，再计算 `3 * 3 = 9`
   - 生成代码：`T1 := 1 + 2`, `y := T1 * 3`

3. **结合性测试**：
   - `10 - 5 - 2` → 左结合：`(10 - 5) - 2 = 3`
   - 生成代码：`T1 := 10 - 5`, `z := T1 - 2`

---

## 错误报告详细示例

### 词法错误示例

**测试代码**：
```cpp
int x = 1 + 2 * 3 @ ;  // 非法字符
int y = 1.2.3 ;        // 多个小数点
int z = 1. ;           // 以小数点结尾
```

**错误输出**：
```
错误: [词法错误] 第1行, 第19列: 非法字符 (遇到字符: '@')
错误: [词法错误] 第2行, 第12列: 数字中不能有多个小数点 (遇到字符: '.')
错误: [词法错误] 第3行, 第11列: 数字不能以小数点结尾 (遇到字符: '.')
```

### 语法错误示例

**测试代码**：
```cpp
int w = 1 + ;  // 缺少操作数
```

**错误输出**：
```
[语法错误] 第4行, 第12列: 遇到意外的符号 ';'
期望的符号: 'i', 'n', '(', '-', '++', '--', 'true', 'false'
```

**说明**：
- 精确指出了错误位置（第4行第12列）
- 显示了实际遇到的符号 `';'`
- 列出了所有期望的符号，帮助理解错误原因

---

## 总结

| 功能 | 支持状态 | 实现方式 | 测试状态 | 详细程度 |
|------|---------|---------|---------|---------|
| 括号 | ✅ 完全支持 | 产生式 G→(E), N→(L) | ✅ 已验证 | 支持表达式和逻辑表达式括号 |
| 运算优先级 | ✅ 完全支持 | 语法层次结构 | ✅ 已验证 | 7层优先级层次 |
| 运算结合性 | ✅ 完全支持 | 左递归（左结合） | ✅ 已验证 | 二元运算符左结合，单目运算符右结合 |
| 词法错误报告 | ✅ 完全支持 | 行号+列号+原因+字符 | ✅ 已验证 | 精确到字符位置 |
| 语法错误报告 | ✅ 完全支持 | 位置+期望符号列表 | ✅ 已验证 | 列出所有可能期望的符号 |

**所有功能均已实现并经过验证！** ✅

### 验证结果

1. **优先级测试**：`1 + 2 * 3` → 正确计算为 7（* 优先于 +）
2. **括号测试**：`( 1 + 2 ) * 3` → 正确计算为 9（括号改变优先级）
3. **结合性测试**：`10 - 5 - 2` → 正确计算为 3（左结合）
4. **错误定位**：所有错误都能精确定位到行号和列号

