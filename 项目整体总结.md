## WHILE 循环语句编译器整体总结

### 一、项目概览

- **项目目标**：实现一个基于 **LR(1)** 语法分析方法的 WHILE 语言编译器，完成从源代码到三地址码（TAC）的完整编译流程，并给出清晰的错误定位与分析信息。
- **主要阶段**：
  - **词法分析**：源代码 → `vector<Word>` 词法单元序列
  - **语法分析（LR(1)）**：Token 序列 → LR(1) 分析过程
  - **语义动作 / 代码生成**：在归约时生成中间代码（四元式 + 三地址码）
  - **错误处理**：词法/语法错误的精确定位与友好诊断

---

### 二、语言特性与实际支持功能

- **程序与语句结构**
  - 程序由语句块 `B` 组成，支持多条语句和嵌套 `while`：
    - `B → S ; B | S ; | A B | A`
  - 语句 `S` 支持：
    - **赋值语句**：`i = E`
    - **变量声明**：
      - `int i;` / `float i;`
      - `int i = E;` / `float i = E;`
    - **表达式语句**：`G`（如 `i++;`、`--j;`）
    - **循环控制语句**：`break;`、`continue;`
  - `while` 循环：
    - `A → while ( L ) M { B }`
    - 支持 **多层嵌套 while**，且 `break / continue` 在多层嵌套中均能正确工作。

- **表达式与布尔逻辑**
  - **算术表达式**
    - `E → E + F | E - F | F`
    - `F → F * G | F / G | G`
    - `G → - G | i | n | ( E ) | i++ | ++i | i-- | --i | true | false`
    - 支持运算符：`+ - * /`、一元负号 `-`、自增/自减 `++/--`。
  - **关系与逻辑表达式**
    - 关系：`C → E ROP E`，`ROP ∈ {>, <, ==, >=, <=, !=}`
    - 逻辑：
      - `L → L || M1 | M1`
      - `M1 → M1 && N | N`
      - `N → !N | C | ( L ) | G`
    - 支持逻辑运算符：`||`、`&&`、`!`，以及布尔常量 `true` / `false`。

- **运算优先级与结合性**
  - **优先级（从高到低）**：
    1. 括号 `( )`
    2. 单目运算：`-`、`!`
    3. 乘除：`*`、`/`
    4. 加减：`+`、`-`
    5. 关系运算：`> < == >= <= !=`
    6. 逻辑与：`&&`
    7. 逻辑或：`||`
  - **结合性**：
    - 二元运算符（`+ - * / && ||`）均通过左递归实现 **左结合**：
      - 例如：`10 - 5 - 2` 解析为 `(10 - 5) - 2`。
    - 单目运算 `-`、`!` 右结合。

- **括号支持**
  - 表达式括号：`G → ( E )`，改变算术优先级。
  - 逻辑表达式括号：`N → ( L )`，用于逻辑表达式分组。
  - `while ( L )`：循环条件必须在括号内。

- **错误报告能力**
  - **词法错误**：
    - 非法字符（含控制字符）、数字格式错误（多个小数点/结尾小数点）、单个 `&/|`、多行注释未闭合等。
    - 报告内容：`[词法错误] 第X行, 第Y列: 原因 (遇到字符: ...)`。
  - **语法错误**：
    - 基于 LR(1) 分析表的当前状态和输入符号检测。
    - 报告内容：
      - 位置：`[语法错误] 第X行, 第Y列: 遇到意外的符号 'a'`
      - 诊断信息：缺少分号、缺少右括号/花括号、表达式不完整、运算符位置错误等。
      - 期望符号列表：按 **关键字 / 运算符 / 分隔符 / 其他** 分组展示。
    - EOF 特殊处理：自动识别缺少 `}` 并指出未匹配 `{` 的行号。

---

### 三、项目结构与模块职责

- **`types.h`**：公共数据结构定义
  - `Word`：词法单元（Token），含符号码、字面值、类型标签和位置信息。
  - `Production`：产生式 `{id, left, right}`。
  - `LR1Item`：LR(1) 项目 `{prodId, dotPos, lookahead}`。
  - `ActionType / Action`：LR 分析表动作（移进/归约/接受/错误）。
  - `TAC`：三地址码指令 `{op, arg1, arg2, result, addr}`。
  - `Quadruple`：四元式 `(op, arg1, arg2, result)`。
  - `SemItem`：语义栈项 `{name}`，用于在语法分析与代码生成间传递语义信息。

- **`lexer.h / lexer.cpp`**：词法分析器 `Lexer`
  - 输入：源代码字符串。
  - 输出：`vector<Word> tokens`，末尾附加结束符 `#`。
  - 职责：
    - 识别关键字（`while/break/continue/int/float/true/false`）、标识符、数字、运算符和分隔符。
    - 对制表符按固定宽度计算列号，使错误列号接近编辑器展示。
    - 详细报出所有词法错误。

- **`parser.h / parser.cpp`**：LR(1) 语法分析器 `Parser`
  - 在构造函数中显式定义 46 条产生式，构建文法。
  - 计算 First 集、构造 LR(1) 项目集族、生成 `actionTable` / `gotoTable`。
  - 将项目集写入 `items.txt`，将分析表写入 `table.csv`。

- **`codegen.h / codegen.cpp`**：代码生成器 `CodeGenerator`
  - 在 LR(1) 归约时执行语义动作，生成：
    - 三地址码序列：`vector<TAC> tacCode`
    - 四元式序列：`vector<Quadruple> quads`
  - 使用栈管理循环：`loopAddrStack`、`breakLists`、`continueLists`，实现 `while` 的条件测试、`break/continue` 跳转和回填。
  - 提供 `printTAC()` 输出最终三地址码。

- **`compiler.h / compiler.cpp`**：编译器主类 `WhileCompiler`
  - 组合并驱动 `Lexer` / `Parser` / `CodeGenerator`。
  - `run(const string& input)`：
    1. 调用 `Lexer` 词法分析并打印 token 表。
    2. 若词法阶段无错误，则使用 `Parser` 提供的分析表进行 LR(1) 语法分析。
    3. 在归约阶段调用 `CodeGenerator::handleProduction` 生成中间代码。
    4. 输出语法分析步骤和最终三地址码。
    5. 集中处理并打印语法错误。

- **`main.cpp`**：程序入口
  - 从文件（默认 `test.txt` 或命令行参数）读取代码，交给 `WhileCompiler::run` 执行。

---

### 四、编译流程与核心算法

#### 1. 词法分析阶段

- **扫描策略**：
  - 单次线性扫描维护 `(line, col)`。
  - `\n`：行号递增、列号重置为 1。
  - 空格：`col++`；制表符：跳到下一个“制表位”（`TAB_WIDTH=4`）。
  - 处理单行注释 `//` 与多行注释 `/* ... */`，多行注释支持未闭合错误提示。

- **Token 构造**：
  - **标识符/关键字**：通过 `isIdStart` / `isIdPart` 扫描。
  - **数字**：支持整数与小数；记录第一个小数点位置，用于构造详细错误信息。
  - **运算符/分隔符**：按最长匹配策略处理 `&&/||/!=/++/--` 等。
  - 所有 Token 统一封装为 `Word{sym, token, typeLabel, line, col}`。

- **错误处理**：
  - 非法字符、数字格式错误、不完整运算符、注释未闭合等均调用 `reportLexicalError`。
  - 若存在词法错误，`WhileCompiler::run` 在词法阶段后直接结束，不再进入语法阶段。

#### 2. 语法分析表构建（LR(1)）

- **First 集计算**：
  - 对每个产生式 `A → α`：
    - 空产生式：`epsilon ∈ First(A)`
    - 若 `α[0]` 为终结符：直接加入 `First(A)`
    - 若为非终结符：加入 `First(α[0]) \ {epsilon}`。

- **闭包 `closure`**：
  - 对项目 `[A → α·Bβ, a]`：
    - 若点后为非终结符 `B`，对所有 `B → γ` 添加项目 `[B → ·γ, First(βa)]`。
    - 合并 lookahead 集以消除冗余。

- **项目集族与分析表**：
  - 初始项目集：`I0 = closure({[S' → ·B, #]})`。
  - 对每个状态 `Ii` 和符号 `X`，计算 `goto(Ii, X)`：
    - 非空则生成新状态或复用已有状态。
    - `X` 为终结符 → `Action[i][X] = SHIFT(next)`。
    - `X` 为非终结符 → `Goto[i][X] = next`。
  - 对项目 `[A → α·, a]`：
    - 若 `A = S'` → `ACCEPT`
    - 否则 `Action[i][a] = REDUCE(A → α)`。

#### 3. LR(1) 语法分析 + 语义动作

- **运行时结构（三栈）**：
  - 状态栈：`stack<int> stateStack`。
  - 符号栈：`stack<string> symbolStack`。
  - 语义栈：`vector<SemItem> semStack`。
  - 辅助栈：`stack<int> braceLineStack` 用于 `{` 的行号记录。

- **Token → 分析符号映射**：
  - 标识符：统一映射为 `i`。
  - 数字：统一映射为 `n`。
  - 关键字/运算符/分隔符：直接使用其 lexeme 作为分析符号。

- **移进（SHIFT）**：
  - 若当前符号为 `while`：
    - 调用 `codegen.enterLoop()` 初始化循环信息。
  - 若当前符号为 `{` / `}`：
    - 更新 `braceLineStack` 用于后续缺 `}` 的错误提示。
  - 将新状态压入 `stateStack`，分析符号压入 `symbolStack`，语义信息 `{w.token}` 压入 `semStack`。

- **归约（REDUCE）**：
  - 弹出产生式右部长度的状态、符号与语义项，按原顺序组成 `popped`。
  - 调用 `codegen.handleProduction(prodId, popped, semStack)` 执行语义动作：
    - 算术、逻辑、关系、赋值、自增自减、声明、`while` 条件与循环控制等都在此生成对应的三地址码与四元式。
  - 将产生式左部非终结符压栈，并依据 `gotoTable` 转移到新状态。
  - 将语义结果 `res` 压回 `semStack`。

- **接受（ACCEPT）**：
  - 分析成功退出循环，随后打印三地址码。

---

### 五、代码生成与循环控制的数据结构与数据流

- **核心存储结构**
  - `vector<TAC> tacCode`：最终三地址码序列，`addr` 字段为指令地址（索引）。
  - `vector<Quadruple> quads`：对应的四元式列表。
  - `string currentStepQuads`：当前语法分析步骤中生成的四元式字符串，用于过程展示。
  - `int tempCount`：临时变量计数器，生成 `T1, T2, ...`。

- **循环控制相关栈**
  - `stack<int> loopAddrStack`：记录每层循环的“条件测试起始地址”。
  - `stack<vector<int>> breakLists`：保存当前循环层内所有 `break`（以及条件失败 `jz`）的指令地址。
  - `stack<vector<int>> continueLists`：保存当前循环层内所有 `continue` 的指令地址。

- **典型数据流（以 `while (L) { B }` 为例）**
  1. **遇到 `while`（SHIFT）**：
     - `enterLoop()`：
       - `loopAddrStack.push(tacCode.size())` 记录条件测试起始地址。
       - 为该层循环分别 `push` 空的 `breakLists` 与 `continueLists`。
  2. **分析条件 `L`**：
     - 表达式部分通过多次归约生成临时变量 `Tcond`，表示条件值。
  3. **归约 `M → ε`**：
     - 从 `semStack` 中读出条件表达式的结果 `lResult.name`。
     - 生成 `jz lResult.name, "", "PENDING_EXIT"`，并将该指令地址记录到当前层 `breakLists.top()` 中。
  4. **循环体 B 内部**：
     - 普通赋值/表达式：按算术/逻辑/关系/赋值产生式生成对应 TAC。
     - `break;`：
       - 生成 `goto PENDING_EXIT`，地址加入 `breakLists.top()`。
     - `continue;`：
       - 生成 `goto PENDING_TEST`，地址加入 `continueLists.top()`。
  5. **归约 `A → while ( L ) M { B }`**：
     - `exitLoop()`：
       - 从 `loopAddrStack` 取出 `testStart`，生成 `goto LtestStart`，实现回到条件判断。
       - 计算当前 `exitAddr = tacCode.size()` 作为循环出口标签。
       - 回填本层所有 `break` 地址为 `LexitAddr`，所有 `continue` 地址为 `LtestStart`。

---

### 六、错误处理设计与数据流向

- **词法错误**
  - 触发点：扫描字符时遇到非法字符、错误数字格式、不完整运算符、注释未闭合等。
  - 数据流：
    - 在 `Lexer` 内调用 `reportLexicalError(line, col, c, reason)`。
    - 将错误信息加入 `lexer.errorMessages` 并立即输出。
    - 词法结束后，`WhileCompiler::run` 若发现 `lexer.hasErrors()` 为真，则直接输出错误汇总并返回。

- **语法错误**
  - 触发点：在 LR(1) 主循环中，当 `actionTable[s]` 中不存在当前分析符号 `a` 的动作时。
  - 期望符号推导：
    - 基于当前状态对应项目集 `states[s]` 中点后的终结符和 lookahead 集，构造 `expected` 集合。
  - EOF 特判：
    - 当前符号为 `#`，且 `{` 数量多于 `}` 或 `expected` 中包含 `}` 时，直接报告缺失 `}`，并利用 `braceLineStack` 报出未匹配 `{` 的行号。
  - 常规错误：
    - 使用当前 Token `w` 的 `line` / `col` 作为错误位置。
    - 调用 `diagnoseSyntaxError` 分析常见错误模式（缺 `;`、缺 `)`、缺 `}`、表达式不完整、运算符位置错误、关键字拼写可能等）。
    - 对 `expected` 中的符号按关键字/运算符/分隔符/其他分组输出，方便理解。

---

### 七、总结

- 本项目实现了一个结构清晰、模块化良好的 WHILE 语言编译器：
  - **词法分析**：支持关键字/运算符/数字/注释等的完整扫描与错误报告。
  - **语法分析**：使用严格的 **LR(1)** 方法，构建完整的项目集与分析表，能力强且可视化良好。
  - **代码生成**：在归约时执行语义动作，生成三地址码与四元式，支持完整的算术/逻辑/关系/声明/自增自减与 `while + break/continue` 控制流。
  - **错误处理**：词法与语法错误均提供精确行列定位、期望符号与诊断信息。
- 通过统一的数据结构（`Word`、`Production`、`LR1Item`、`SemItem`、`TAC` 等）和清晰的数据流，本项目展示了一条从源代码到中间代码的完整编译流水线，适合作为编译原理课程的综合实践项目参考。 




