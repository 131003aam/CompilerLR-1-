# 属性文法设计文档

## 一、属性文法概述

属性文法是上下文无关文法的扩展，通过在文法符号（终结符和非终结符）上附加**属性（attributes）**和**语义规则（semantic rules）**来描述程序设计语言的语义。

### 属性定义

本项目中的主要属性：
- **name**：综合属性，表示变量名、常量名或临时变量名，自底向上传递（子节点→父节点）
- **NXQ**：继承属性，表示当前四元式代码生成位置（代码生成器内部维护）

### 语义动作函数

- **GEN(op, arg1, arg2, result)**：生成四元式 `(op, arg1, arg2, result)`
- **newTemp()**：生成新的临时变量名（如 T1, T2, ...）
- **enterLoop()**：进入循环，记录循环开始地址
- **exitLoop()**：退出循环，回填break和continue的跳转地址
- **backpatch(addr, target)**：回填跳转地址

---

## 二、属性文法表

### 表1：WHILE循环语句属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **A → while ( L ) M { B }** | `{`<br>`  enterLoop();`<br>`  // M归约时：生成条件判断代码`<br>`  // 如果 L.name != "true"，生成：jz L.name, _, PENDING_EXIT`<br>`  // 将jz指令地址加入breakLists`<br>`  // B归约时：生成循环体代码`<br>`  exitLoop();`<br>`  // 生成：j _, _, L{testStart}`<br>`  // 回填所有break到循环结束地址`<br>`  // 回填所有continue到testStart地址`<br>`}` |
| **M → ε** | `{`<br>`  // 获取条件表达式结果 L.name`<br>`  if (L.name != "true") {`<br>`    NXQ = GEN("jz", L.name, "_", "PENDING_EXIT");`<br>`    breakLists.top().push_back(NXQ - 1);`<br>`  }`<br>`}` |

---

### 表2：逻辑表达式属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **L → L₁ \|\| M1** | `{`<br>`  L.name = newTemp();`<br>`  GEN("||", L₁.name, M1.name, L.name);`<br>`}` |
| **L → M1** | `{`<br>`  L.name = M1.name;`<br>`}` |
| **M1 → M1₁ && N** | `{`<br>`  M1.name = newTemp();`<br>`  GEN("&&", M1₁.name, N.name, M1.name);`<br>`}` |
| **M1 → N** | `{`<br>`  M1.name = N.name;`<br>`}` |
| **N → ! N₁** | `{`<br>`  N.name = newTemp();`<br>`  GEN("!", N₁.name, "_", N.name);`<br>`}` |
| **N → C** | `{`<br>`  N.name = C.name;`<br>`}` |
| **N → ( L )** | `{`<br>`  N.name = L.name;`<br>`}` |
| **N → G** | `{`<br>`  N.name = G.name;`<br>`}` |

---

### 表3：关系表达式属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **C → E₁ ROP E₂** | `{`<br>`  C.name = newTemp();`<br>`  GEN(ROP.token, E₁.name, E₂.name, C.name);`<br>`  // ROP.token 为 ">", "<", "==", ">=", "<=", "!=" 之一`<br>`}` |

---

### 表4：赋值语句属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **S → i = E ;** | `{`<br>`  GEN("=", E.name, "_", i.name);`<br>`  S.name = i.name;`<br>`}` |

---

### 表5：算术表达式属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **E → E₁ + F** | `{`<br>`  E.name = newTemp();`<br>`  GEN("+", E₁.name, F.name, E.name);`<br>`}` |
| **E → E₁ - F** | `{`<br>`  E.name = newTemp();`<br>`  GEN("-", E₁.name, F.name, E.name);`<br>`}` |
| **E → F** | `{`<br>`  E.name = F.name;`<br>`}` |
| **F → F₁ * G** | `{`<br>`  F.name = newTemp();`<br>`  GEN("*", F₁.name, G.name, F.name);`<br>`}` |
| **F → F₁ / G** | `{`<br>`  F.name = newTemp();`<br>`  GEN("/", F₁.name, G.name, F.name);`<br>`}` |
| **F → G** | `{`<br>`  F.name = G.name;`<br>`}` |
| **G → - G₁** | `{`<br>`  G.name = newTemp();`<br>`  GEN("neg", G₁.name, "_", G.name);`<br>`}` |
| **G → i** | `{`<br>`  G.name = i.name;`<br>`}` |
| **G → n** | `{`<br>`  G.name = n.lexval;`<br>`  // n.lexval 为数字常量的字符串表示`<br>`}` |
| **G → ( E )** | `{`<br>`  G.name = E.name;`<br>`}` |

---

### 表6：自增自减表达式属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **G → i ++** | `{`<br>`  // 后缀自增：先保存原值，再自增，返回原值`<br>`  oldValue = newTemp();`<br>`  GEN("=", i.name, "_", oldValue);`<br>`  t = newTemp();`<br>`  GEN("+", i.name, "1", t);`<br>`  GEN("=", t, "_", i.name);`<br>`  G.name = oldValue;`<br>`}` |
| **G → ++ i** | `{`<br>`  // 前缀自增：先自增，再返回新值`<br>`  t = newTemp();`<br>`  GEN("+", i.name, "1", t);`<br>`  GEN("=", t, "_", i.name);`<br>`  G.name = i.name;`<br>`}` |
| **G → i --** | `{`<br>`  // 后缀自减：先保存原值，再自减，返回原值`<br>`  oldValue = newTemp();`<br>`  GEN("=", i.name, "_", oldValue);`<br>`  t = newTemp();`<br>`  GEN("-", i.name, "1", t);`<br>`  GEN("=", t, "_", i.name);`<br>`  G.name = oldValue;`<br>`}` |
| **G → -- i** | `{`<br>`  // 前缀自减：先自减，再返回新值`<br>`  t = newTemp();`<br>`  GEN("-", i.name, "1", t);`<br>`  GEN("=", t, "_", i.name);`<br>`  G.name = i.name;`<br>`}` |

---

### 表7：控制流语句属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **S → break ;** | `{`<br>`  NXQ = GEN("j", "_", "_", "PENDING_EXIT");`<br>`  breakLists.top().push_back(NXQ - 1);`<br>`}` |
| **S → continue ;** | `{`<br>`  NXQ = GEN("j", "_", "_", "PENDING_TEST");`<br>`  continueLists.top().push_back(NXQ - 1);`<br>`}` |

---

### 表8：变量声明属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **S → int i ;** | `{`<br>`  GEN("decl", "int", "_", i.name);`<br>`  S.name = i.name;`<br>`}` |
| **S → float i ;** | `{`<br>`  GEN("decl", "float", "_", i.name);`<br>`  S.name = i.name;`<br>`}` |
| **S → int i = E ;** | `{`<br>`  GEN("decl", "int", "_", i.name);`<br>`  GEN("=", E.name, "_", i.name);`<br>`  S.name = i.name;`<br>`}` |
| **S → float i = E ;** | `{`<br>`  GEN("decl", "float", "_", i.name);`<br>`  GEN("=", E.name, "_", i.name);`<br>`  S.name = i.name;`<br>`}` |

---

### 表9：布尔常量和表达式语句属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **G → true** | `{`<br>`  G.name = "true";`<br>`}` |
| **G → false** | `{`<br>`  G.name = "false";`<br>`}` |
| **S → G ;** | `{`<br>`  S.name = G.name;`<br>`  // 表达式语句，不生成赋值代码`<br>`}` |

---

### 表10：复合语句属性文法

| 产生式 | 语义规则 |
|--------|----------|
| **B → S ; B₁** | `{`<br>`  // 顺序执行，无需特殊语义动作`<br>`}` |
| **B → S ;** | `{`<br>`  // 单个语句，无需特殊语义动作`<br>`}` |
| **B → A B₁** | `{`<br>`  // while循环后跟语句块，无需特殊语义动作`<br>`}` |
| **B → A** | `{`<br>`  // 单个while循环，无需特殊语义动作`<br>`}` |

---

## 三、中间代码形式的定义

### 3.1 中间代码形式概述

本项目采用**三地址码（Three Address Code, TAC）**作为主要的中间代码表示形式，同时保留**四元式（Quadruple）**形式用于语法分析过程的实时展示。这两种形式在语义上等价，但在实现细节和使用场景上有所不同。

### 3.2 三地址码（TAC）定义

#### 3.2.1 数据结构定义

三地址码在代码中通过 `TAC` 结构体表示：

```cpp
struct TAC {
    string op;      // 操作符：如 "+", "-", "=", "jz", "goto" 等
    string arg1;    // 第一个操作数：变量名、常量或临时变量
    string arg2;    // 第二个操作数：对于二元运算使用，一元运算可为空
    string result;  // 结果变量或跳转目标：存储运算结果或跳转地址
    int addr;       // 指令地址：该指令在三地址码序列中的索引位置
};
```

#### 3.2.2 指令格式说明

每条三地址码指令的基本格式为：`(op, arg1, arg2, result)`，其中：

- **op**：操作符，表示指令的类型
- **arg1**：第一个操作数（对于一元运算，arg2 为空）
- **arg2**：第二个操作数（对于一元运算或赋值，arg2 为空或使用占位符 "_"）
- **result**：结果变量（对于赋值、算术运算）或跳转目标（对于跳转指令）
- **addr**：指令在代码序列中的地址，用于跳转指令的地址回填

#### 3.2.3 指令类型分类

根据操作符的不同，三地址码指令可分为以下几类：

**1. 算术运算指令**
- 格式：`(op, arg1, arg2, result)`
- 操作符：`+`, `-`, `*`, `/`, `neg`（取负）
- 语义：`result := arg1 op arg2` 或 `result := op arg1`
- 示例：
  - `(+, a, b, T1)` 表示 `T1 := a + b`
  - `(neg, x, _, T2)` 表示 `T2 := -x`

**2. 关系运算指令**
- 格式：`(op, arg1, arg2, result)`
- 操作符：`>`, `<`, `==`, `>=`, `<=`, `!=`
- 语义：`result := (arg1 op arg2)`，结果为布尔值（临时变量）
- 示例：
  - `(>, x, 0, T1)` 表示 `T1 := (x > 0)`

**3. 逻辑运算指令**
- 格式：`(op, arg1, arg2, result)`
- 操作符：`&&`, `||`, `!`
- 语义：`result := arg1 op arg2` 或 `result := !arg1`
- 示例：
  - `(&&, T1, T2, T3)` 表示 `T3 := T1 && T2`
  - `(!, T1, _, T2)` 表示 `T2 := !T1`

**4. 赋值指令**
- 格式：`(=, arg1, _, result)` 或 `(:=, arg1, _, result)`
- 语义：`result := arg1`
- 示例：
  - `(=, T1, _, x)` 表示 `x := T1`

**5. 条件跳转指令**
- 格式：`(jz, arg1, _, result)`
- 语义：`if arg1 == 0 goto result`
- 说明：当 `arg1` 为 0（假）时跳转到 `result` 指定的地址
- 示例：
  - `(jz, T1, _, L5)` 表示 `if T1 == 0 goto L5`

**6. 无条件跳转指令**
- 格式：`(goto, _, _, result)` 或 `(j, _, _, result)`
- 语义：`goto result`
- 示例：
  - `(goto, _, _, L0)` 表示 `goto L0`

**7. 变量声明指令**
- 格式：`(decl, type, _, result)`
- 语义：声明类型为 `type` 的变量 `result`
- 示例：
  - `(decl, int, _, x)` 表示声明整型变量 `x`
  - `(decl, float, _, y)` 表示声明浮点型变量 `y`

### 3.3 四元式（Quadruple）定义

#### 3.3.1 数据结构定义

四元式在代码中通过 `Quadruple` 结构体表示：

```cpp
struct Quadruple {
    string op;      // 操作符
    string arg1;    // 第一个操作数
    string arg2;    // 第二个操作数
    string result;  // 结果变量
    string toString() const {
        return "(" + op + ", " + arg1 + ", " + arg2 + ", " + result + ")";
    }
};
```

#### 3.3.2 与三地址码的关系

四元式与三地址码在格式上完全相同，都是 `(op, arg1, arg2, result)` 的形式，主要区别在于：

1. **用途不同**：
   - **三地址码（TAC）**：作为最终生成的中间代码，用于后续的代码优化和目标代码生成
   - **四元式（Quadruple）**：主要用于在语法分析过程中实时展示每一步归约时生成的代码，增强可视化和调试能力

2. **存储方式不同**：
   - **TAC**：存储在 `vector<TAC> tacCode` 中，每条指令带有 `addr` 字段用于地址回填
   - **Quadruple**：存储在 `vector<Quadruple> quads` 中，主要用于显示

3. **生成时机**：
   - 两者在语义动作中**并行生成**，每次调用 `emit()` 生成 TAC 的同时，调用 `emitQuad()` 生成对应的 Quadruple

### 3.4 中间代码生成规则

#### 3.4.1 临时变量命名规则

- 所有中间计算结果使用临时变量存储
- 临时变量命名规则：`T1`, `T2`, `T3`, ...（通过 `newTemp()` 函数自动生成）
- 临时变量计数器 `tempCount` 从 0 开始，每次生成新临时变量时递增

#### 3.4.2 地址回填机制

对于控制流语句（如 `while` 循环），跳转目标在生成时可能尚未确定，因此采用**回填机制**：

1. **占位符**：
   - `PENDING_EXIT`：表示待回填的循环退出地址（用于 `break` 和条件跳转）
   - `PENDING_TEST`：表示待回填的循环测试开始地址（用于 `continue`）

2. **回填时机**：
   - 在 `exitLoop()` 函数中统一回填所有待回填的地址
   - 使用 `backpatch(addr, target)` 函数修改已生成指令的 `result` 字段

3. **地址表示**：
   - 最终回填的地址格式为 `L0`, `L1`, `L2`, ...（`L` + 指令地址）

#### 3.4.3 代码生成流程

中间代码的生成遵循以下流程：

1. **语法分析阶段**：在 LR(1) 分析器进行归约时，调用语义动作函数
2. **语义动作执行**：根据产生式规则，调用 `CodeGenerator::handleProduction()` 生成代码
3. **代码生成**：
   - 调用 `emit()` 生成三地址码，存储到 `tacCode`
   - 调用 `emitQuad()` 生成四元式，存储到 `quads` 并更新 `currentStepQuads`
4. **地址回填**：在循环、条件语句等控制结构结束时，回填待定地址
5. **最终输出**：通过 `printTAC()` 函数格式化输出所有生成的三地址码

### 3.5 实验验证与分析

#### 3.5.1 中间代码生成验证

通过测试用例验证中间代码生成的正确性：

**测试用例1：简单算术表达式**
```
源代码：x = a + b * 2;
```

**生成的三地址码**：
```
L0 | T1 := b * 2
L1 | T2 := a + T1
L2 | x := T2
```

**分析**：
- 正确体现了运算符优先级（乘法优先于加法）
- 使用临时变量存储中间结果
- 赋值操作正确生成

**测试用例2：while循环**
```
源代码：while (x > 0) { x = x - 1; }
```

**生成的三地址码**：
```
L0 | T1 := x > 0
L1 | if T1 == 0 goto L4
L2 | T2 := x - 1
L3 | x := T2
L4 | goto L0
```

**分析**：
- 条件判断正确生成条件跳转指令
- 循环体代码正确生成
- 循环结束时的无条件跳转正确回填到循环开始

#### 3.5.2 四元式与三地址码一致性验证

通过对比 `quads` 和 `tacCode` 的内容，验证两者的一致性：

- **格式一致性**：两者都采用 `(op, arg1, arg2, result)` 格式
- **内容一致性**：除 `addr` 字段外，两者的 `op`、`arg1`、`arg2`、`result` 字段完全一致
- **生成同步性**：每次语义动作同时生成两种形式的代码，确保同步

#### 3.5.3 地址回填机制验证

通过嵌套循环测试用例验证地址回填机制的正确性：

**测试用例：嵌套while循环**
```
源代码：
while (x > 0) {
    while (y > 0) {
        break;
    }
    continue;
}
```

**验证点**：
- 内层循环的 `break` 正确回填到内层循环结束
- 外层循环的 `continue` 正确回填到外层循环开始
- 使用栈结构确保嵌套循环的地址回填互不干扰

### 3.6 总结

本项目的中间代码形式设计具有以下特点：

1. **双重表示**：同时使用三地址码和四元式，兼顾最终代码生成和过程可视化
2. **格式统一**：两种形式采用相同的 `(op, arg1, arg2, result)` 格式，便于理解和维护
3. **地址管理**：通过 `addr` 字段和回填机制，支持控制流语句的正确代码生成
4. **临时变量**：自动生成临时变量，简化代码生成逻辑
5. **可扩展性**：指令格式设计灵活，易于添加新的操作符和指令类型

---

## 四、属性传递说明

### 综合属性（Synthesized Attribute）

所有属性均为**综合属性**，自底向上传递：
- **name** 属性从叶子节点（标识符、常量）开始，向上传递到表达式、语句等非终结符
- 在归约时，根据产生式规则计算父节点的 name 属性

### 继承属性（Inherited Attribute）

- **NXQ**（当前代码生成位置）由代码生成器内部维护，作为隐式继承属性
- **breakLists** 和 **continueLists** 通过栈结构维护，用于回填跳转地址

---

## 五、代码生成说明

### 四元式格式

所有语义动作生成的代码均为**四元式**格式：`(op, arg1, arg2, result)`

### 特殊处理

1. **循环控制**：
   - `enterLoop()` 记录循环开始地址（testStart）
   - `exitLoop()` 生成跳转回循环开始，并回填break和continue的地址

2. **临时变量**：
   - 所有中间计算结果使用 `newTemp()` 生成临时变量（T1, T2, ...）

3. **回填机制**：
   - break和continue的跳转目标初始为 "PENDING_EXIT" 和 "PENDING_TEST"
   - 在 `exitLoop()` 时统一回填为实际地址

---

## 六、示例

### 示例1：赋值语句 `x = a + b;`

```
产生式归约序列：
G → a          (G.name = "a")
G → b          (G.name = "b")
F → G          (F.name = "b")
E → F          (E.name = "b")
F → G          (F.name = "a")
E → E + F      (E.name = T1, GEN("+", "a", "b", "T1"))
S → i = E      (GEN("=", "T1", "_", "x"))
```

生成的四元式：
```
(+, a, b, T1)
(=, T1, _, x)
```

### 示例2：while循环 `while(x > 0) { x = x - 1; }`

```
产生式归约序列：
G → x          (G.name = "x")
G → 0          (G.name = "0")
F → G          (F.name = "0")
E → F          (E.name = "0")
F → G          (F.name = "x")
E → F          (E.name = "x")
C → E > E      (C.name = T1, GEN(">", "x", "0", "T1"))
N → C          (N.name = "T1")
M1 → N         (M1.name = "T1")
L → M1         (L.name = "T1")
M → ε          (GEN("jz", "T1", "_", "PENDING_EXIT"))
... (循环体代码生成)
A → while(L)M{B}  (exitLoop(), 回填地址)
```

生成的四元式：
```
(>, x, 0, T1)
(jz, T1, _, L3)      // 假设循环结束地址为L3
(-, x, 1, T2)
(=, T2, _, x)
(j, _, _, L0)        // 跳转回循环开始L0
```

---

## 七、总结

本项目的属性文法设计特点：

1. **属性类型**：主要使用综合属性（name），通过语义栈传递
2. **代码生成**：采用四元式作为中间代码表示
3. **循环控制**：使用回填机制处理break和continue语句
4. **临时变量**：自动生成临时变量存储中间计算结果
5. **表达式求值**：自底向上计算表达式值，生成相应的四元式代码


