# 编译器错误处理系统设计文档

## 一、设计概述

### 1.1 设计原则

本编译器的错误处理系统遵循以下核心设计原则：

1. **错误触发基于分析栈**：错误检测来自 LR(1) 语法分析器的状态栈和符号栈
2. **错误定位基于源代码 Token**：所有错误位置信息都来自词法分析产生的 Token，而非 LR 状态
3. **错误呈现面向用户**：错误信息使用自然语言，提供诊断和修复建议
4. **错误诊断智能化**：自动识别常见错误模式，提供针对性提示

### 1.2 架构层次

```
源代码
  ↓
词法分析器 (Lexer)
  ├─ Token 序列（含位置信息）
  └─ 词法错误报告
  ↓
语法分析器 (Parser)
  ├─ LR(1) 分析表
  └─ 状态栈 + 符号栈
  ↓
错误处理系统 (Error Handler)
  ├─ 错误检测（基于分析栈）
  ├─ 错误定位（基于 Token）
  ├─ 错误诊断（模式识别）
  └─ 错误呈现（用户友好）
```

---

## 二、词法分析错误处理

### 2.1 错误检测机制

**触发条件**：
- 遇到非法字符
- 数字格式错误（多个小数点、以小数点结尾）
- 运算符不完整（单个 `&`、`|`）
- 注释未闭合

**错误定位**：
```cpp
// 使用 Token 起始位置，而非当前扫描位置
reportLexicalError(startLine, startCol, input[i], reason);
```

**设计思考**：
- ✅ 使用 `startLine` 和 `startCol` 而非 `line` 和 `col`
- ✅ 原因：Token 起始位置更准确，避免列号计算偏差
- ✅ 错误位置指向 Token 开始，符合用户直觉

### 2.2 错误信息分类

#### 2.2.1 数字错误

**实现**：
```cpp
// 多个小数点
if (dot > 0) {
    reportLexicalError(startLine, startCol, input[i], 
        "数字中不能有多个小数点（第一个小数点在数字开始位置）");
}

// 以小数点结尾
if (buf.back() == '.') {
    reportLexicalError(startLine, startCol, '.', 
        "数字不能以小数点结尾（数字从第X行第Y列开始）");
}
```

**设计思考**：
- 提供错误原因和位置上下文
- 说明数字的开始位置，帮助用户理解错误范围

#### 2.2.2 运算符错误

**实现**：
```cpp
// 单个 & 或 |
if (input[i] == '&' && input[i+1] != '&') {
    reportLexicalError(startLine, startCol, input[i], 
        "缺少运算符：期望 '&&'（逻辑与），但遇到单个 '&'。建议：检查是否遗漏了第二个 '&'");
}
```

**设计思考**：
- 明确指出期望的符号
- 提供修复建议（检查是否遗漏）
- 说明运算符的语义（逻辑与/逻辑或）

#### 2.2.3 注释错误

**实现**：
```cpp
// 多行注释未闭合
if (!foundEnd) {
    string msg = "多行注释未闭合：注释从第" + to_string(commentStartLine) + 
                "行第" + to_string(commentStartCol) + "列开始（/*），但未找到结束标记（*/）";
    if (lastLine > commentStartLine) {
        msg += "。注释跨越了" + to_string(lastLine - commentStartLine + 1) + "行，在文件末尾仍未闭合";
    }
    msg += "。提示：从第 " + to_string(commentStartLine) + " 行开始的 '/*' 未找到匹配的 '*/'";
    reportLexicalError(commentStartLine, commentStartCol, '\0', msg);
}
```

**设计思考**：
- 记录注释开始位置（`commentStartLine`, `commentStartCol`）
- 显示注释跨越的行数
- 提供匹配提示（从第X行开始的 `/*` 未找到匹配的 `*/`）
- 帮助用户快速定位未闭合的注释

#### 2.2.4 非法字符错误

**实现**：
```cpp
// 非法字符
string charDesc = "";
if (input[i] == '\0') charDesc = "空字符";
else if (input[i] < 32) charDesc = "控制字符（ASCII码: " + to_string((int)input[i]) + "）";
else charDesc = string("'") + input[i] + "'";

reportLexicalError(startLine, startCol, input[i], 
    "非法字符 " + charDesc + "。建议：检查是否使用了不支持的字符，或是否遗漏了运算符/分隔符");
```

**设计思考**：
- 区分不同类型的非法字符（空字符、控制字符、普通字符）
- 对于控制字符，显示 ASCII 码值
- 提供修复建议（检查字符或遗漏的符号）

### 2.3 列号计算优化

**实现**：
```cpp
// 制表符宽度（可配置）
static const int TAB_WIDTH = 4;

// 制表符处理
if (input[i] == '\t') {
    // 计算下一个制表符停止位
    int nextTabStop = ((col - 1) / TAB_WIDTH + 1) * TAB_WIDTH + 1;
    col = nextTabStop;
}
```

**设计思考**：
- 使用可配置的 `TAB_WIDTH` 常量
- 计算下一个制表符停止位，而非简单 +4
- 提高列号准确性，符合编辑器显示

---

## 三、语法分析错误处理

### 3.1 错误检测机制

**触发条件**：
```cpp
// LR(1) 分析表中无对应动作
if (!actionTable.at(s).count(a)) {
    // 触发语法错误处理
}
```

**错误来源**：
- **状态栈**：当前 LR(1) 状态 `s = stateStack.top()`
- **符号栈**：已识别的符号序列
- **当前 Token**：`w = tokens[ptr]`，包含位置信息 `w.line`, `w.col`

**设计思考**：
- ✅ 错误触发来自分析栈（LR 状态）
- ✅ 错误定位基于 Token（源代码位置）
- ✅ 符合编译器标准做法（GCC、Clang 等）

### 3.2 错误定位

**实现**：
```cpp
// 所有错误位置都来自 Token
errorMsg = "[语法错误] 第" + to_string(w.line) + "行, 第" + to_string(w.col) + "列: ";
```

**设计思考**：
- ❌ **不推荐**：`error.line = stateStack.top().line`（用户不懂 LR 状态）
- ✅ **推荐**：`error.line = currentToken.line`（用户只看源代码）
- ✅ IDE/编译器都是这样做的

### 3.3 代码块位置跟踪

**实现**：
```cpp
// 维护代码块位置栈
stack<int> braceLineStack;  // 记录每个 { 的行号

// 移进 { 时
if (a == "{") {
    braceLineStack.push(w.line);  // 记录行号
}

// 移进 } 时
else if (a == "}") {
    if (!braceLineStack.empty()) {
        braceLineStack.pop();  // 弹出匹配的 {
    }
}
```

**设计思考**：
- 使用栈结构自动处理嵌套代码块
- 记录 `{` 的行号，而非列号（行号更直观）
- 在错误时从栈顶获取未匹配的 `{` 位置

### 3.4 特殊错误处理

#### 3.4.1 EOF 时缺少 `}`

**实现**：
```cpp
if (a == "#") {  // 文件结束符
    // 检查符号栈中 { 和 } 的匹配情况
    int openBraces = 0, closeBraces = 0;
    for (const auto& sym : symbols) {
        if (sym == "{") openBraces++;
        else if (sym == "}") closeBraces++;
    }
    
    if (openBraces > closeBraces || expected.count("}")) {
        errorMsg = "[语法错误] 缺少右花括号 '}'";
        // 从位置栈获取未匹配的 { 的位置
        if (!braceLineStack.empty()) {
            int unclosedBraceLine = braceLineStack.top();
            errorMsg += "\n提示：从第 " + to_string(unclosedBraceLine) + 
                       " 行开始的 '{' 未找到匹配的 '}'";
        }
    }
}
```

**设计思考**：
- 优先检测常见错误（缺少 `}`）
- 提供未匹配符号的位置信息
- 帮助用户快速定位问题

#### 3.4.2 常规错误诊断

**实现**：
```cpp
// 诊断常见错误模式
string diagnoseSyntaxError(const string& currentSymbol, 
                          const set<string>& expected, 
                          const stack<string>& symbolStack, 
                          const vector<Word>& tokens, 
                          int ptr) {
    // 1. 检查缺少分号
    if (expected.count(";")) {
        return "缺少分号 ';'。建议：在语句末尾添加分号";
    }
    
    // 2. 检查缺少右括号
    if (expected.count(")")) {
        // 检查括号匹配...
        return "缺少右括号 ')'。建议：检查是否有未闭合的左括号 '('";
    }
    
    // 3. 检查缺少右花括号
    if (expected.count("}")) {
        // 检查花括号匹配...
        return "缺少右花括号 '}'。建议：检查是否有未闭合的左花括号 '{'";
    }
    
    // 4. 检查运算符位置错误
    // 5. 检查关键字拼写错误
    // 6. 检查表达式不完整
    // ...
}
```

**设计思考**：
- 按优先级检查常见错误模式
- 提供具体的修复建议
- 减少用户猜测时间

### 3.5 期望符号展示优化

**实现**：
```cpp
// 分组显示期望符号
vector<string> keywords, operators, separators, others;

// 分类
for (const auto& exp : expected) {
    if (kwSet.count(exp)) keywords.push_back(exp);
    else if (opSet.count(exp)) operators.push_back(exp);
    else if (sepSet.count(exp)) separators.push_back(exp);
    else others.push_back(exp);
}

// 格式化输出
errorMsg += "\n期望的符号: ";
if (!keywords.empty()) errorMsg += "关键字(...)";
if (!operators.empty()) errorMsg += ", 运算符(...)";
if (!separators.empty()) errorMsg += ", 分隔符(...)";
```

**设计思考**：
- 分组显示更清晰（关键字、运算符、分隔符）
- 避免长列表难以阅读
- 符合用户认知习惯

---

## 四、错误处理流程

### 4.1 完整错误处理流程

```
1. 词法分析阶段
   ├─ 扫描字符
   ├─ 识别 Token
   ├─ 记录位置（startLine, startCol）
   └─ 检测词法错误 → 报告并继续/停止

2. 语法分析阶段
   ├─ LR(1) 分析循环
   ├─ 移进/归约操作
   ├─ 维护位置栈（braceLineStack）
   └─ 检测语法错误 → 诊断 → 报告

3. 错误报告阶段
   ├─ 收集错误信息
   ├─ 诊断错误模式
   ├─ 格式化错误消息
   └─ 输出给用户
```

### 4.2 错误信息结构

```
[错误类型] 第X行, 第Y列: 错误描述
诊断: 具体诊断信息
提示: 从第 Z 行开始的 '符号' 未找到匹配的 '符号'
期望的符号: 关键字(...), 运算符(...), 分隔符(...)
```

---

## 五、设计优势

### 5.1 准确性

- ✅ 错误位置基于 Token，而非 LR 状态
- ✅ 列号计算考虑制表符
- ✅ 代码块位置跟踪准确

### 5.2 用户友好

- ✅ 错误信息使用自然语言
- ✅ 提供诊断和修复建议
- ✅ 期望符号分组显示

### 5.3 智能化

- ✅ 自动识别常见错误模式
- ✅ 优先报告最可能的错误
- ✅ 提供上下文信息（未匹配符号位置）

### 5.4 可维护性

- ✅ 错误处理逻辑模块化
- ✅ 诊断函数独立，易于扩展
- ✅ 代码结构清晰

---

## 六、实现细节总结

### 6.1 关键数据结构

```cpp
// 词法分析
int startLine, startCol;  // Token 起始位置
int commentStartLine, commentStartCol;  // 注释开始位置

// 语法分析
stack<int> braceLineStack;  // 代码块位置栈
stack<string> symbolStack;  // 符号栈
stack<int> stateStack;  // 状态栈
```

### 6.2 关键函数

```cpp
// 词法分析
void reportLexicalError(int line, int col, char c, const string& reason);

// 语法分析
string diagnoseSyntaxError(...);  // 错误诊断
// 错误报告（内联在 compiler.cpp 中）
```

### 6.3 错误类型覆盖

**词法错误**：
- ✅ 非法字符
- ✅ 数字格式错误
- ✅ 运算符不完整
- ✅ 注释未闭合

**语法错误**：
- ✅ 缺少分号
- ✅ 缺少右括号
- ✅ 缺少右花括号
- ✅ 运算符位置错误
- ✅ 关键字拼写错误
- ✅ 表达式不完整

---

## 七、未来扩展方向

### 7.1 错误恢复

- 尝试插入缺失符号继续分析
- 跳过错误 Token 继续分析
- 提供多个修复方案

### 7.2 错误上下文

- 显示错误附近的代码片段
- 显示当前分析状态（"在 while 循环体内"）
- 高亮错误位置

### 7.3 错误统计

- 统计错误类型分布
- 提供错误修复建议优先级
- 生成错误报告文件

---

## 八、关键实现细节

### 8.1 错误位置跟踪的完整流程

```cpp
// 1. 词法分析阶段：记录 Token 起始位置
int startLine = line, startCol = col;  // 每个 Token 开始时记录
// ... 识别 Token ...
tokens.push_back({ sym, buf, typeLabel, startLine, startCol });

// 2. 语法分析阶段：维护代码块位置栈
stack<int> braceLineStack;
if (a == "{") {
    braceLineStack.push(w.line);  // 记录 { 的行号
}
else if (a == "}") {
    if (!braceLineStack.empty()) {
        braceLineStack.pop();  // 弹出匹配的 {
    }
}

// 3. 错误报告阶段：使用 Token 位置
errorMsg = "[语法错误] 第" + to_string(w.line) + "行, 第" + to_string(w.col) + "列: ";
if (!braceLineStack.empty()) {
    errorMsg += "\n提示：从第 " + to_string(braceLineStack.top()) + 
               " 行开始的 '{' 未找到匹配的 '}'";
}
```

### 8.2 错误诊断的优先级

错误诊断按以下优先级进行：

1. **EOF 特殊处理**（最高优先级）
   - 检测到 `#` 且缺少 `}`
   - 直接报告，不进行其他诊断

2. **常见错误模式**（高优先级）
   - 缺少分号 `;`
   - 缺少右括号 `)`
   - 缺少右花括号 `}`

3. **运算符和关键字错误**（中优先级）
   - 运算符位置错误
   - 关键字拼写错误

4. **表达式错误**（低优先级）
   - 表达式不完整

### 8.3 错误信息的层次结构

```
第一层：错误类型和位置
  [语法错误] 第X行, 第Y列: 遇到意外的符号 'Z'

第二层：错误诊断（如果识别到模式）
  诊断: 缺少分号 ';'。建议：在语句末尾添加分号

第三层：位置提示（如果有未匹配的符号）
  提示：从第 Z 行开始的 '{' 未找到匹配的 '}'

第四层：期望符号列表（分组显示）
  期望的符号: 关键字(while, break), 运算符(+, -), 分隔符(;, })
```

### 8.4 设计决策对比

| 方面 | 错误做法 ❌ | 正确做法 ✅ | 原因 |
|------|-----------|-----------|------|
| 错误位置 | `stateStack.top().line` | `currentToken.line` | 用户只看源代码，不懂 LR 状态 |
| 错误触发 | 基于 Token 内容 | 基于分析栈状态 | LR 分析器通过状态检测错误 |
| 位置跟踪 | 不跟踪代码块 | 维护位置栈 | 提供未匹配符号的位置 |
| 错误信息 | 简单列表 | 分组+诊断 | 更易理解和修复 |

---

## 九、实际应用示例

### 9.1 示例 1：缺少右花括号

**源代码**：
```c
while ( true ) {
    float b_flag = 1.5 ;
    if_val = a_var ;
```

**错误报告**：
```
[语法错误] 缺少右花括号 '}'
提示：从第 1 行开始的 '{' 未找到匹配的 '}'
```

**设计要点**：
- 错误触发：EOF 时检测到 `openBraces > closeBraces`
- 错误定位：使用当前 Token（`#`）的位置
- 位置提示：从 `braceLineStack.top()` 获取未匹配的 `{` 位置

### 9.2 示例 2：缺少分号

**源代码**：
```c
int a = 1
float b = 2.0;
```

**错误报告**：
```
[语法错误] 第1行, 第12列: 遇到意外的符号 'float'
诊断: 缺少分号 ';'。建议：在语句末尾添加分号
期望的符号: 分隔符(;)
```

**设计要点**：
- 错误触发：期望 `;` 但遇到 `float`
- 错误诊断：识别到"缺少分号"模式
- 期望符号：分组显示，只显示分隔符

### 9.3 示例 3：注释未闭合

**源代码**：
```c
/* 这是一个未闭合的注释
int a = 1;
```

**错误报告**：
```
[词法错误] 第1行, 第1列: 多行注释未闭合：注释从第1行第1列开始（/*），但未找到结束标记（*/）。注释跨越了2行，在文件末尾仍未闭合。提示：从第 1 行开始的 '/*' 未找到匹配的 '*/'
```

**设计要点**：
- 记录注释开始位置（`commentStartLine`, `commentStartCol`）
- 显示注释跨越的行数
- 提供匹配提示

---

## 十、总结

本错误处理系统实现了：

1. **准确的错误定位**：基于 Token 位置，符合用户直觉
2. **智能的错误诊断**：自动识别常见错误模式
3. **友好的错误呈现**：提供诊断、建议和上下文信息
4. **完善的错误覆盖**：涵盖词法和语法的主要错误类型
5. **位置跟踪机制**：维护代码块位置栈，提供未匹配符号的位置

### 10.1 设计优势

- ✅ **技术正确性**：错误触发基于 LR 分析栈，符合编译器理论
- ✅ **用户友好性**：错误定位基于源代码，符合用户认知
- ✅ **可扩展性**：诊断函数模块化，易于添加新错误模式
- ✅ **可维护性**：代码结构清晰，职责分离

### 10.2 符合标准实践

本设计遵循了主流编译器（GCC、Clang、MSVC）的错误处理实践：
- 错误位置基于源代码 Token
- 提供诊断和修复建议
- 分组显示期望符号
- 跟踪未匹配符号的位置

设计既保证了技术正确性，又提供了良好的用户体验。

