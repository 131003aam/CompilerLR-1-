#ifndef TYPES_H
#define TYPES_H

#include <string>
#include <vector>
#include <set>

using namespace std;

// ============================================================================
// 数据结构定义模块 (types.h)
// ============================================================================
// 本模块定义了编译器中使用的所有核心数据结构，包括词法单元、语法产生式、
// LR(1)分析项目、三地址码等。这些数据结构贯穿整个编译过程。

// ----------------------------------------------------------------------------
// 词法单元 (Word)
// ----------------------------------------------------------------------------
// 表示词法分析器识别出的一个词法单元（Token）
// 包含该词法单元的所有相关信息，用于后续的语法分析和错误报告
struct Word {
    int sym;            // 符号码：内部编码，用于语法分析（0=标识符, 1=数字, 2=运算符等）
    string token;       // 词法值：原始字符串，如 "while", "123", "+" 等
    string typeLabel;   // 类型标签：用于显示的描述，如 "关键字", "标识符", "运算符" 等
    int line;           // 行号：词法单元在源文件中的行号（从1开始）
    int col;            // 列号：词法单元在源文件中的列号（从1开始）
};

// ----------------------------------------------------------------------------
// 产生式 (Production)
// ----------------------------------------------------------------------------
// 表示上下文无关文法的一个产生式规则
// 用于定义语言的语法结构
struct Production {
    int id;                 // 产生式编号：唯一标识符，用于LR分析表中的归约动作
    string left;            // 左部：非终结符，如 "E", "S", "B" 等
    vector<string> right;  // 右部：产生式右部的符号序列，如 {"E", "+", "F"}
};

// ----------------------------------------------------------------------------
// 四元式 (Quadruple)
// ----------------------------------------------------------------------------
// 表示中间代码的一种形式：四元式 (op, arg1, arg2, result)
// 用于在语法分析过程中记录语义动作生成的中间代码
struct Quadruple {
    string op;      // 操作符：如 "+", "-", "=", "jz" 等
    string arg1;    // 第一个操作数：可以是变量名、常量或临时变量
    string arg2;    // 第二个操作数：对于二元运算使用，一元运算可为空
    string result;  // 结果：存储运算结果的变量或临时变量
    string toString() const {
        return "(" + op + ", " + arg1 + ", " + arg2 + ", " + result + ")";
    }
};

// ----------------------------------------------------------------------------
// LR(1) 项目 (LR1Item)
// ----------------------------------------------------------------------------
// 表示LR(1)分析中的一个项目，包含产生式、点位置和向前看符号集合
// 这是LR(1)分析方法的核心数据结构
struct LR1Item {
    int prodId;             // 产生式ID：指向对应的产生式
    int dotPos;             // 点位置：表示分析进度，点之前的部分已识别
    set<string> lookahead;  // 向前看符号集合：用于解决归约-归约冲突

    // 比较操作符：用于项目集的比较和去重
    bool operator<(const LR1Item& other) const {
        if (prodId != other.prodId) return prodId < other.prodId;
        if (dotPos != other.dotPos) return dotPos < other.dotPos;
        return lookahead < other.lookahead;
    }
    bool operator==(const LR1Item& other) const {
        return prodId == other.prodId && dotPos == other.dotPos && lookahead == other.lookahead;
    }
};

// ----------------------------------------------------------------------------
// 动作类型 (ActionType)
// ----------------------------------------------------------------------------
// LR分析表中动作的类型
enum class ActionType { 
    SHIFT,   // 移进：将当前输入符号移入栈，并转移到新状态
    REDUCE, // 归约：使用某个产生式进行归约
    ACCEPT, // 接受：成功识别输入，分析完成
    ERROR   // 错误：遇到语法错误
};

// ----------------------------------------------------------------------------
// 分析表动作 (Action)
// ----------------------------------------------------------------------------
// LR分析表中每个表项的动作
struct Action {
    ActionType type = ActionType::ERROR;  // 动作类型
    int target = -1;                      // 目标：对于SHIFT是状态号，对于REDUCE是产生式ID
};

// ----------------------------------------------------------------------------
// 三地址码 (TAC - Three Address Code)
// ----------------------------------------------------------------------------
// 最终生成的中间代码表示形式
// 每条指令最多包含三个地址（两个操作数和一个结果）
struct TAC {
    string op;      // 操作符
    string arg1;    // 第一个操作数
    string arg2;    // 第二个操作数
    string result;  // 结果变量
    int addr;       // 指令地址：用于跳转指令的目标地址
};

// ----------------------------------------------------------------------------
// 语义栈项 (SemItem)
// ----------------------------------------------------------------------------
// 语义分析栈中的项，存储语法分析过程中需要的语义信息
// 主要用于代码生成时传递变量名、临时变量等信息
struct SemItem {
    string name;    // 名称：变量名或临时变量名
};

#endif // TYPES_H




