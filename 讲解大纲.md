# 编译器项目讲解大纲（简洁版）

## 一、开场（1分钟）
- 项目定位：基于LR(1)的编译器前端
- 主要功能：词法分析、语法分析、语义分析、中间代码生成
- 技术特点：LR(1)分析、属性文法、三地址码

---

## 二、核心功能演示（10分钟）

### 1. 基本算术运算（1.5分钟）
- **支持**：`+`、`-`、`*`、`/`、一元负号`-`
- **演示**：`int x = 1 + 2 * 3;`（展示优先级）
- **技术**：通过语法层次（E→F→G）实现优先级

### 2. 关系运算（1分钟）
- **支持**：6种运算符 `>`、`<`、`==`、`>=`、`<=`、`!=`
- **演示**：`while (x > y) { ... }`
- **技术**：产生式 `C → E ROP E`，生成比较指令

### 3. 逻辑运算（1分钟）
- **支持**：3种运算符 `&&`、`||`、`!`
- **演示**：`while ((x > 0) && (y < 10)) { ... }`
- **技术**：通过语法层次实现优先级，左递归实现左结合

### 4. 赋值语句（0.5分钟）
- **支持**：`变量 = 表达式`、`int x = 5;`
- **演示**：`x = 1 + 2 * 3;`

### 5. 运算优先级和结合性（2分钟）
- **优先级**（从高到低）：
  1. 括号 `( )`
  2. 单目：`-`、`!`
  3. 乘除：`*`、`/`
  4. 加减：`+`、`-`
  5. 关系：`> < == >= <= !=`
  6. 逻辑与：`&&`
  7. 逻辑或：`||`
- **结合性**：
  - 二元运算符：**左结合**（通过左递归实现）
  - 单目运算符：**右结合**（通过右递归实现）
- **演示**：`int x = 10 - 5 - 2;`（左结合：`(10-5)-2 = 3`）

### 6. 括号支持（1分钟）
- **三种场景**：
  1. 表达式括号：`(1 + 2) * 3`
  2. 逻辑表达式括号：`(a > 0) && (b < 10)`
  3. 循环条件括号：`while (x > 0) { ... }`
- **技术**：`G → (E)`、`N → (L)`

### 7. 复合语句（0.5分钟）
- **支持**：多个语句顺序执行，用分号分隔
- **演示**：多个赋值语句和while循环混合

### 8. 嵌套结构（1.5分钟）
- **支持**：嵌套的while循环、嵌套的复合语句
- **技术**：使用栈机制（`loopAddrStack`、`breakLists`、`continueLists`）
- **演示**：两层嵌套循环

---

## 三、控制流语句（3分钟）

### 1. while循环（1.5分钟）
- **语法**：`while (条件) { 循环体 }`
- **技术**：地址回填机制
  - `enterLoop()`：记录循环开始地址
  - 生成条件判断代码
  - `exitLoop()`：生成跳回指令，回填break/continue地址
- **演示**：`while (x > 0) { x = x - 1; }`
- **中间代码**：展示条件跳转和循环回跳

### 2. break和continue（1.5分钟）
- **break**：跳出当前循环
- **continue**：跳过当前循环体，继续下一次循环
- **技术**：地址回填机制
  - break：跳转到循环结束地址
  - continue：跳转到循环开始地址
- **演示**：嵌套循环中的break/continue

---

## 四、自增自减（1.5分钟）

### 前缀和后缀的区别
- **前缀**（`++i`、`--i`）：先自增/自减，再返回新值
- **后缀**（`i++`、`i--`）：先保存原值，再自增/自减，返回原值
- **演示**：`int y = ++x;` vs `int z = x++;`
- **技术**：通过不同的代码生成序列实现

---

## 五、错误处理（4分钟）

### 1. 词法错误（2分钟）
- **错误类型**：
  1. 非法字符
  2. 数字格式错误（多个小数点、以小数点结尾）
  3. 运算符不完整（单个`&`、`|`）
  4. 注释未闭合
- **特点**：精确位置（行号、列号）+ 详细原因 + 修复建议
- **演示**：展示各种词法错误及其报告

### 2. 语法错误（2分钟）
- **错误类型**：
  1. 缺少分号
  2. 缺少右括号/右花括号
  3. 运算符位置错误
  4. 表达式不完整
- **特点**：
  - 基于LR(1)分析表检测
  - 智能诊断（识别常见错误模式）
  - 分组显示期望符号
  - EOF时自动检测缺少`}`
- **演示**：展示各种语法错误及其报告

---

## 六、其他特色（1.5分钟）

### 1. 变量声明
- 支持`int`和`float`类型
- 支持声明时赋值

### 2. 布尔常量
- 支持`true`和`false`

### 3. 表达式语句
- 支持单独的表达式作为语句：`x++;`

### 4. 中间代码生成
- 生成三地址码（TAC）
- 支持地址回填
- 使用临时变量存储中间结果

---

## 七、总结（1分钟）

### 项目亮点
1. 完整的编译器前端实现
2. 强大的错误处理能力
3. 正确的代码生成
4. 支持复杂特性（嵌套、自增自减等）

### 技术特色
1. LR(1)语法分析
2. 属性文法
3. 栈机制支持嵌套
4. 地址回填处理控制流

---

## 八、时间分配

| 部分 | 时长 |
|------|------|
| 开场 | 1分钟 |
| 核心功能 | 10分钟 |
| 控制流语句 | 3分钟 |
| 自增自减 | 1.5分钟 |
| 错误处理 | 4分钟 |
| 其他特色 | 1.5分钟 |
| 总结 | 1分钟 |
| **总计** | **约22分钟** |

---

## 九、讲解技巧

### 1. 演示顺序
- 先演示正确代码 → 展示功能
- 再演示错误代码 → 展示错误处理
- 最后展示中间代码 → 说明代码生成

### 2. 重点强调
- **技术实现**：LR(1)、属性文法、地址回填
- **错误处理**：精确定位、智能诊断
- **代码质量**：中间代码正确、高效

### 3. 互动建议
- 准备测试用例，现场演示
- 展示错误报告的实际效果
- 对比不同优先级表达式的解析结果

---

## 十、关键演示代码

### 优先级测试
```c
int x = 1 + 2 * 3;        // 结果：7
int y = (1 + 2) * 3;      // 结果：9
int z = 10 - 5 - 2;       // 结果：3（左结合）
```

### 嵌套循环
```c
while (x > 0) {
    while (y > 0) {
        break;      // 只跳出内层循环
    }
    continue;       // 只影响外层循环
}
```

### 自增自减
```c
int x = 5;
int y = ++x;    // y=6, x=6
int z = x++;    // z=6, x=7
```

### 错误演示
```c
int x = 1@2;        // 词法错误：非法字符
int y = 1          // 语法错误：缺少分号
while (x > 0 {     // 语法错误：缺少右括号
```

---

## 十一、可能的问题

### Q: 为什么选择LR(1)？
**A**: LR(1)分析能力更强，可以处理左递归，更适合表达式分析。

### Q: 如何处理运算符优先级？
**A**: 通过语法层次结构（E→F→G）实现，归约顺序自然体现优先级。

### Q: 嵌套循环的break如何区分？
**A**: 使用栈结构，每个循环层有自己的break列表。

### Q: 错误定位为什么准确？
**A**: 词法分析记录Token位置，语法错误使用Token位置而非LR状态位置。

### Q: 自增自减如何实现？
**A**: 前缀先计算新值返回新值，后缀先保存原值再计算返回原值。

